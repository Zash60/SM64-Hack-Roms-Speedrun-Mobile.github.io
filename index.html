<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM64 Hacks Speedrun Mobile</title>
    <link rel="icon" href="data:,"> <!-- Prevent favicon 404 -->
    <style>
        body { font-family: Arial, sans-serif; background: #121212; color: #fff; margin: 0; padding: 0; }
        header { background: #1f1f1f; padding: 10px; text-align: center; }
        nav { display: flex; justify-content: center; }
        nav button { margin: 5px; padding: 10px; background: #333; color: #fff; border: none; cursor: pointer; }
        #content { padding: 10px; }
        .game-card { background: #222; margin: 10px 0; padding: 10px; display: flex; align-items: center; }
        .game-card img { width: 50px; margin-right: 10px; }
        #search { width: 100%; padding: 10px; margin-bottom: 10px; }
        #sort { padding: 10px; margin-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #333; }
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; }
        #modal-content { background: #222; padding: 20px; width: 80%; max-width: 400px; }
        input, select { width: 100%; padding: 10px; margin: 5px 0; }
        @media (max-width: 600px) { .game-card { flex-direction: column; text-align: center; } }
    </style>
</head>
<body>
    <header>
        <h1>SM64 Hacks Speedrun Mobile</h1>
        <nav>
            <button onclick="navigate('home')">Home</button>
            <button onclick="navigate('mod')">Mod</button>
        </nav>
    </header>
    <div id="content"></div>
    <div id="modal">
        <div id="modal-content">
            <h2>Submit Run</h2>
            <input id="player" placeholder="Player Name" required>
            <input id="time" placeholder="Time (mm:ss.ms)" required>
            <input id="video" placeholder="Video URL" required>
            <input id="date" type="date" required>
            <button onclick="submitRun()">Submit</button>
            <button onclick="closeModal()">Close</button>
        </div>
    </div>
    <script type="module">
        // Firebase Imports (Updated to latest version 12.3.0)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getDatabase, ref, push, set, onValue, remove, update } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyAsVYnWAq5aFOz9dIxHpGVWK8Mk64f01GU",
            authDomain: "sm64-hack-roms-speedrun-mobile.firebaseapp.com",
            databaseURL: "https://sm64-hack-roms-speedrun-mobile-default-rtdb.firebaseio.com",
            projectId: "sm64-hack-roms-speedrun-mobile",
            storageBucket: "sm64-hack-roms-speedrun-mobile.appspot.com",
            messagingSenderId: "499101981060",
            appId: "1:499101981060:web:209dfe3f20866ef4f865d1"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // Global Variables
        let games = [];
        let currentGame = null;
        let currentType = '';
        let currentCat = '';
        let currentSub = '';
        let user = null;

        // Caching Helper
        function getCached(key) {
            const cached = localStorage.getItem(key);
            if (cached) {
                const { data, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < 3600000) return data; // 1 hour
            }
            return null;
        }
        function setCached(key, data) {
            localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        }

        // Fetch All Games (Handles Pagination)
        async function fetchGames() {
            let cached = getCached('games');
            if (cached) return cached;
            let offset = 0;
            const max = 200;
            let allGames = [];
            while (true) {
                const res = await fetch(`https://www.speedrun.com/api/v1/series/sm64romhacks/games?offset=${offset}&max=${max}`);
                const json = await res.json();
                allGames.push(...json.data);
                if (json.pagination.size < max) break;
                offset += max;
            }
            setCached('games', allGames);
            return allGames;
        }

        // Fetch Game Data (Categories, Levels, Variables)
        async function fetchGameData(gameId, type) {
            const key = `game_${gameId}_${type}`;
            let cached = getCached(key);
            if (cached) return cached;
            const res = await fetch(`https://www.speedrun.com/api/v1/games/${gameId}/${type}`);
            const json = await res.json();
            setCached(key, json.data);
            return json.data;
        }

        // Relative Time
        function relativeTime(released) {
            const now = new Date(); // Use current date
            const diff = now.getFullYear() - released;
            return `${diff} years ago`;
        }

        // Parse Time to Seconds
        function parseTime(str) {
            const [min, secMs] = str.split(':');
            const [sec, ms] = secMs.split('.');
            return parseInt(min)*60 + parseInt(sec) + parseFloat(`0.${ms || 0}`);
        }

        // Format Time from Seconds
        function formatTime(sec) {
            const min = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            const ms = Math.round((sec - Math.floor(sec)) * 1000);
            return `${min}m ${s}s ${ms}ms`;
        }

        // Navigation
        function navigate(page) {
            window.location.hash = page;
        }

        async function renderPage() {
            const hash = window.location.hash.slice(1) || 'home';
            const parts = hash.split('/');
            const content = document.getElementById('content');
            content.innerHTML = '';
            if (hash === 'home') {
                games = await fetchGames();
                renderHome(content);
            } else if (hash === 'mod') {
                renderMod(content);
            } else if (parts[0] === 'game') {
                const gameId = parts[1];
                currentGame = games.find(g => g.id === gameId);
                currentType = parts[2]; // fullgame or level
                currentCat = parts[3];
                currentSub = parts[4] || '';
                if (currentType === 'fullgame') {
                    renderFullGameLeaderboard(content, gameId);
                } else if (currentType === 'level') {
                    const levelId = parts[3]; // Fixed: parts[2] is 'level', parts[3] is levelId, parts[4] cat, parts[5] sub
                    currentType = 'level-' + levelId;
                    currentCat = parts[4];
                    currentSub = parts[5] || '';
                    renderLevelLeaderboard(content, gameId, levelId);
                }
            }
        }

        // Render Home
        function renderHome(content) {
            const search = document.createElement('input');
            search.id = 'search';
            search.placeholder = 'Search games...';
            search.oninput = filterGames;
            content.appendChild(search);

            const sort = document.createElement('select');
            sort.id = 'sort';
            sort.innerHTML = `<option>Alphabetical</option><option>Most Recent</option><option>Oldest</option>`;
            sort.onchange = filterGames;
            content.appendChild(sort);

            const list = document.createElement('div');
            list.id = 'game-list';
            content.appendChild(list);
            filterGames();
        }

        function filterGames() {
            const query = document.getElementById('search').value.toLowerCase();
            const sortVal = document.getElementById('sort').value;
            let filtered = games.filter(g => g.names.international.toLowerCase().includes(query));
            if (sortVal === 'Alphabetical') filtered.sort((a,b) => a.names.international.localeCompare(b.names.international));
            if (sortVal === 'Most Recent') filtered.sort((a,b) => b.released - a.released);
            if (sortVal === 'Oldest') filtered.sort((a,b) => a.released - b.released);
            const list = document.getElementById('game-list');
            list.innerHTML = '';
            filtered.forEach(g => {
                const card = document.createElement('div');
                card.className = 'game-card';
                const coverUri = (g.assets['cover-tiny'].uri || '').replace(/^http:/, 'https:'); // Fix mixed content
                card.innerHTML = `<img src="${coverUri}" alt="${g.names.international}">
                    <div><h3>${g.names.international}</h3><p>${g.released} (${relativeTime(g.released)})</p></div>`;
                card.onclick = () => navigate(`game/${g.id}/fullgame`);
                list.appendChild(card);
            });
        }

        // Render Full Game Leaderboard
        async function renderFullGameLeaderboard(content, gameId) {
            content.innerHTML = `<h2>${currentGame.names.international} - Full Game</h2>`;
            const cats = await fetchGameData(gameId, 'categories');
            const vars = await fetchGameData(gameId, 'variables');
            const fullCats = cats.filter(c => c.type === 'per-game');
            const selectCat = document.createElement('select');
            fullCats.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.text = c.name;
                if (c.id === currentCat) opt.selected = true;
                selectCat.appendChild(opt);
            });
            selectCat.onchange = () => navigate(`game/${gameId}/fullgame/${selectCat.value}`);
            content.appendChild(selectCat);

            // Subcategories (Variables for full-game)
            const fullVars = vars.filter(v => v['is-subcategory'] && (v.scope.type === 'full-game' || v.scope.type === 'all'));
            if (fullVars.length) {
                const selectSub = document.createElement('select');
                Object.entries(fullVars[0].values.values).forEach(([id, val]) => { // Fixed: Use Object.entries for id
                    const opt = document.createElement('option');
                    opt.value = `${fullVars[0].id}-${id}`;
                    opt.text = val.label;
                    if (opt.value === currentSub) opt.selected = true;
                    selectSub.appendChild(opt);
                });
                selectSub.onchange = () => navigate(`game/${gameId}/fullgame/${currentCat}/${selectSub.value}`);
                content.appendChild(selectSub);
            }

            renderLeaderboardTable(content, gameId, 'fullgame', currentCat, currentSub);
            const btn = document.createElement('button');
            btn.textContent = 'Submit Run';
            btn.onclick = () => openModal('fullgame', currentCat, currentSub);
            content.appendChild(btn);
        }

        // Render Level Leaderboard
        async function renderLevelLeaderboard(content, gameId, levelId) {
            content.innerHTML = `<h2>${currentGame.names.international} - Levels</h2>`;
            const levels = await fetchGameData(gameId, 'levels');
            const levelSelect = document.createElement('select');
            levels.forEach(l => {
                const opt = document.createElement('option');
                opt.value = l.id;
                opt.text = l.name;
                if (l.id === levelId) opt.selected = true;
                levelSelect.appendChild(opt);
            });
            levelSelect.onchange = () => navigate(`game/${gameId}/level/${levelSelect.value}/${currentCat || ''}/${currentSub || ''}`);
            content.appendChild(levelSelect);

            const cats = await fetchGameData(gameId, 'categories');
            const levelCats = cats.filter(c => c.type === 'per-level');
            const catSelect = document.createElement('select');
            levelCats.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.text = c.name; // e.g., Single Star, Stage RTA
                if (c.id === currentCat) opt.selected = true;
                catSelect.appendChild(opt);
            });
            catSelect.onchange = () => navigate(`game/${gameId}/level/${levelId}/${catSelect.value}/${currentSub || ''}`);
            content.appendChild(catSelect);

            // For Single Star, show star dropdown (variables for single-level)
            const isSingleStar = levelCats.find(c => c.id === currentCat && c.name.includes('Single Star'));
            if (isSingleStar) {
                const vars = await fetchGameData(gameId, 'variables');
                const levelVars = vars.filter(v => v['is-subcategory'] && v.scope.type === 'single-level' && v.scope.level === levelId);
                if (levelVars.length) {
                    const starSelect = document.createElement('select');
                    Object.entries(levelVars[0].values.values).forEach(([id, val]) => {
                        const opt = document.createElement('option');
                        opt.value = `${levelVars[0].id}-${id}`;
                        opt.text = val.label;
                        if (opt.value === currentSub) opt.selected = true;
                        starSelect.appendChild(opt);
                    });
                    starSelect.onchange = () => navigate(`game/${gameId}/level/${levelId}/${currentCat}/${starSelect.value}`);
                    content.appendChild(starSelect);
                }
            }

            renderLeaderboardTable(content, gameId, `level-${levelId}`, currentCat, currentSub);
            const btn = document.createElement('button');
            btn.textContent = 'Submit Run';
            btn.onclick = () => openModal(`level-${levelId}`, currentCat, currentSub);
            content.appendChild(btn);
        }

        // Render Leaderboard Table (Real-time)
        function renderLeaderboardTable(content, gameId, type, catId, sub) {
            const table = document.createElement('table');
            table.innerHTML = `<tr><th>#</th><th>Player</th><th>Time</th><th>Date</th><th>Video</th></tr>`;
            content.appendChild(table);
            const path = `runs/${gameId}/${type}/${catId}/${sub || 'default'}`;
            onValue(ref(db, path), snapshot => {
                const runs = [];
                snapshot.forEach(child => {
                    const run = child.val();
                    if (run.approved) runs.push({ ...run, key: child.key });
                });
                runs.sort((a,b) => a.time - b.time);
                table.innerHTML = `<tr><th>#</th><th>Player</th><th>Time</th><th>Date</th><th>Video</th></tr>`;
                runs.forEach((run, i) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${i+1}</td><td>${run.player}</td><td>${formatTime(run.time)}</td><td>${run.date}</td><td><a href="${run.video}">Link</a></td>`;
                    table.appendChild(tr);
                });
            });
        }

        // Submit Run Modal
        function openModal(type, cat, sub) {
            currentType = type;
            currentCat = cat;
            currentSub = sub;
            document.getElementById('modal').style.display = 'flex';
        }
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }
        async function submitRun() {
            const player = document.getElementById('player').value;
            const timeStr = document.getElementById('time').value;
            const video = document.getElementById('video').value;
            const date = document.getElementById('date').value;
            if (!player || !timeStr || !video || !date) return alert('Fill all fields');
            const time = parseTime(timeStr);
            const run = { gameId: currentGame.id, type: currentType, cat: currentCat, sub: currentSub || 'default', player, time, video, date, approved: false };
            const newRef = push(ref(db, 'pending_runs'));
            await set(newRef, run);
            closeModal();
            alert('Run submitted for approval');
        }

        // Render Mod Page
        function renderMod(content) {
            if (!user) {
                content.innerHTML = `<h2>Mod Login</h2>
                    <input id="email" placeholder="Email">
                    <input id="password" type="password" placeholder="Password">
                    <button onclick="login()">Login</button>
                    <button onclick="signup()">Sign Up (For Testing)</button>`;
                return;
            }
            content.innerHTML = `<h2>Moderation Panel</h2><button onclick="logout()">Logout</button>`;
            const table = document.createElement('table');
            table.innerHTML = `<tr><th>Game</th><th>Player</th><th>Time</th><th>Video</th><th>Date</th><th>Actions</th></tr>`;
            content.appendChild(table);
            onValue(ref(db, 'pending_runs'), snapshot => {
                table.innerHTML = `<tr><th>Game</th><th>Player</th><th>Time</th><th>Video</th><th>Date</th><th>Actions</th></tr>`;
                snapshot.forEach(child => {
                    const run = child.val();
                    const gameName = games.find(g => g.id === run.gameId)?.names.international || 'Unknown';
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${gameName}</td><td>${run.player}</td><td>${formatTime(run.time)}</td><td><a href="${run.video}">Link</a></td><td>${run.date}</td>`;
                    const actions = document.createElement('td');
                    const approveBtn = document.createElement('button');
                    approveBtn.textContent = 'Approve';
                    approveBtn.onclick = () => approveRun(child.key, run);
                    actions.appendChild(approveBtn);
                    const rejectBtn = document.createElement('button');
                    rejectBtn.textContent = 'Reject';
                    rejectBtn.onclick = () => remove(ref(db, `pending_runs/${child.key}`));
                    actions.appendChild(rejectBtn);
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => editRun(child.key, run);
                    actions.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => remove(ref(db, `pending_runs/${child.key}`));
                    actions.appendChild(deleteBtn);
                    tr.appendChild(actions);
                    table.appendChild(tr);
                });
            });
        }

        async function approveRun(key, run) {
            run.approved = true;
            const path = `runs/${run.gameId}/${run.type}/${run.cat}/${run.sub}`;
            const newRef = push(ref(db, path));
            await set(newRef, run);
            await remove(ref(db, `pending_runs/${key}`));
        }

        function editRun(key, run) {
            const newPlayer = prompt('New Player', run.player);
            const newTimeStr = prompt('New Time (mm:ss.ms)', formatTime(run.time).replace(/m |s /g, ':').replace('ms', ''));
            const newVideo = prompt('New Video URL', run.video);
            const newDate = prompt('New Date (YYYY-MM-DD)', run.date);
            if (newPlayer && newTimeStr && newVideo && newDate) {
                const newTime = parseTime(newTimeStr);
                update(ref(db, `pending_runs/${key}`), {
                    player: newPlayer,
                    time: newTime,
                    video: newVideo,
                    date: newDate
                });
            }
        }

        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                const cred = await signInWithEmailAndPassword(auth, email, password);
                user = cred.user;
                renderMod(document.getElementById('content'));
            } catch (e) {
                alert('Login failed: ' + e.message);
            }
        }

        async function signup() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                alert('Signed up');
            } catch (e) {
                alert('Signup failed: ' + e.message);
            }
        }

        function logout() {
            auth.signOut();
            user = null;
            renderMod(document.getElementById('content'));
        }

        // Make functions global for inline onclick
        window.navigate = navigate;
        window.login = login;
        window.signup = signup;
        window.logout = logout;
        window.submitRun = submitRun;
        window.closeModal = closeModal;

        // Init
        auth.onAuthStateChanged(u => {
            user = u;
            if (window.location.hash === '#mod') renderMod(document.getElementById('content'));
        });
        window.onhashchange = renderPage;
        renderPage();
    </script>
</body>
</html>
