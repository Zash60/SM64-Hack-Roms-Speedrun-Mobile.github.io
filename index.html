<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM64 Hacks Speedrun Mobile</title>
    <link rel="icon" href="data:,"> <!-- Prevent favicon 404 -->
    <style>
        body { font-family: Arial, sans-serif; background: #121212; color: #fff; margin: 0; padding: 0; }
        header { background: #1f1f1f; padding: 10px; text-align: center; }
        nav { display: flex; justify-content: center; }
        nav button { margin: 5px; padding: 10px; background: #333; color: #fff; border: none; cursor: pointer; }
        #content { padding: 10px; }
        .game-card { background: #222; margin: 10px 0; padding: 10px; display: flex; align-items: center; }
        .game-card img { width: 50px; margin-right: 10px; }
        #search { width: 100%; padding: 10px; margin-bottom: 10px; }
        #sort { padding: 10px; margin-bottom: 10px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #333; }
        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; }
        #modal-content { background: #222; padding: 20px; width: 80%; max-width: 400px; }
        input, select { width: 100%; padding: 10px; margin: 5px 0; }
        @media (max-width: 600px) { .game-card { flex-direction: column; text-align: center; } }
    </style>
</head>
<body>
    <header>
        <h1>SM64 Hacks Speedrun Mobile</h1>
        <nav>
            <button id="home-btn">Home</button>
            <button id="mod-btn">Mod</button>
        </nav>
    </header>
    <div id="content"></div>
    <div id="modal">
        <div id="modal-content">
            <h2>Submit Run</h2>
            <input id="player" placeholder="Player Name" required>
            <input id="time" placeholder="Time (mm:ss.ms)" required>
            <input id="video" placeholder="Video URL" required>
            <input id="date" type="date" required>
            <button id="submit-btn">Submit</button>
            <button id="close-btn">Close</button>
        </div>
    </div>
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getDatabase, ref, push, set, onValue, remove, update } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyAsVYnWAq5aFOz9dIxHpGVWK8Mk64f01GU",
            authDomain: "sm64-hack-roms-speedrun-mobile.firebaseapp.com",
            databaseURL: "https://sm64-hack-roms-speedrun-mobile-default-rtdb.firebaseio.com",
            projectId: "sm64-hack-roms-speedrun-mobile",
            storageBucket: "sm64-hack-roms-speedrun-mobile.appspot.com",
            messagingSenderId: "499101981060",
            appId: "1:499101981060:web:209dfe3f20866ef4f865d1"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getDatabase(app);

        // Global Variables
        let games = [];
        let currentGame = null;
        let currentType = '';
        let currentCat = '';
        let currentSub = '';
        let user = null;

        // Caching Helper
        function getCached(key) {
            const cached = localStorage.getItem(key);
            if (cached) {
                const { data, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < 3600000) return data; // 1 hour
            }
            return null;
        }
        function setCached(key, data) {
            localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        }

        // Fetch All Games (Handles Pagination and Rate-Limited Full Data Fetch)
        async function fetchGames() {
            let cached = getCached('games');
            if (cached) return cached;
            let offset = 0;
            const max = 200;
            let seriesGames = [];
            while (true) {
                const res = await fetch(`https://www.speedrun.com/api/v1/series/sm64romhacks/games?offset=${offset}&max=${max}`);
                const json = await res.json();
                seriesGames.push(...json.data);
                if (json.pagination.size < max) break;
                offset += max;
            }
            // Rate-limited fetch for full game data (sequential with delay and retry on 429)
            for (let i = 0; i < seriesGames.length; i++) {
                const g = seriesGames[i];
                const gameKey = `game_${g.id}`;
                let full = getCached(gameKey);
                if (!full) {
                    try {
                        const res = await fetch(`https://www.speedrun.com/api/v1/games/${g.id}`);
                        if (res.status === 429) {
                            console.log('Rate limit hit, waiting 60s...');
                            await new Promise(r => setTimeout(r, 60000));
                            i--; // Retry this fetch
                            continue;
                        }
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        const json = await res.json();
                        full = json.data;
                        setCached(gameKey, full);
                    } catch (e) {
                        console.error(`Failed to fetch ${g.id}: ${e}`);
                        full = {}; // Fallback
                    }
                }
                g.releaseDate = full['release-date'] || null;
                await new Promise(r => setTimeout(r, 200)); // 200ms delay to avoid burst
            }
            setCached('games', seriesGames);
            return seriesGames;
        }

        // Fetch Game Data (Categories, Levels, Variables)
        async function fetchGameData(gameId, type) {
            const key = `game_${gameId}_${type}`;
            let cached = getCached(key);
            if (cached) return cached;
            const res = await fetch(`https://www.speedrun.com/api/v1/games/${gameId}/${type}`);
            const json = await res.json();
            setCached(key, json.data);
            return json.data;
        }

        // Relative Time
        function relativeTime(game) {
            const now = new Date(2025, 8, 25); // September 25, 2025
            let release;
            if (game.releaseDate) {
                release = new Date(game.releaseDate);
            } else {
                release = new Date(game.released, 0, 1); // Jan 1
            }
            const diffMs = now - release;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const diffMonths = Math.floor(diffDays / 30);
            const diffYears = Math.floor(diffMonths / 12);
            if (diffYears >= 1) {
                return `${diffYears} years ago`;
            } else if (diffMonths >= 1) {
                return `${diffMonths} months ago`;
            } else {
                return `${diffDays} days ago`;
            }
        }

        // Parse Time to Seconds
        function parseTime(str) {
            const [min, secMs] = str.split(':');
            const [sec, ms] = secMs.split('.');
            return parseInt(min)*60 + parseInt(sec) + parseFloat(`0.${ms || 0}`);
        }

        // Format Time from Seconds
        function formatTime(sec) {
            const min = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            const ms = Math.round((sec - Math.floor(sec)) * 1000);
            return `${min}m ${s}s ${ms}ms`;
        }

        // Navigation
        function navigate(page) {
            window.location.hash = page;
        }

        async function renderPage() {
            const hash = window.location.hash.slice(1) || 'home';
            const parts = hash.split('/');
            const content = document.getElementById('content');
            content.innerHTML = '';
            if (hash === 'home') {
                games = await fetchGames();
                renderHome(content);
            } else if (hash === 'mod') {
                renderMod(content);
            } else if (parts[0] === 'game') {
                const gameId = parts[1];
                currentGame = games.find(g => g.id === gameId);
                if (parts[2] === 'fullgame') {
                    currentType = parts[2];
                    currentCat = parts[3];
                    currentSub = parts[4] || '';
                    renderFullGameLeaderboard(content, gameId);
                } else if (parts[2] === 'level') {
                    const levelId = parts[3];
                    currentType = 'level-' + levelId;
                    currentCat = parts[4] || '';
                    currentSub = parts[5] || '';
                    renderLevelLeaderboard(content, gameId, levelId);
                }
            }
        }

        // Render Home
        function renderHome(content) {
            const search = document.createElement('input');
            search.id = 'search';
            search.placeholder = 'Search games...';
            search.oninput = filterGames;
            content.appendChild(search);

            const sort = document.createElement('select');
            sort.id = 'sort';
            sort.innerHTML = `<option>Alphabetical</option><option>Most Recent</option><option>Oldest</option>`;
            sort.onchange = filterGames;
            content.appendChild(sort);

            const list = document.createElement('div');
            list.id = 'game-list';
            content.appendChild(list);
            filterGames();
        }

        function filterGames() {
            const query = document.getElementById('search').value.toLowerCase();
            const sortVal = document.getElementById('sort').value;
            let filtered = games.filter(g => g.names.international.toLowerCase().includes(query));
            if (sortVal === 'Alphabetical') {
                filtered.sort((a, b) => a.names.international.localeCompare(b.names.international));
            } else {
                // Sort by full date timestamp
                filtered.sort((a, b) => {
                    const dateA = Date.parse(a.releaseDate || `${a.released}-01-01`);
                    const dateB = Date.parse(b.releaseDate || `${b.released}-01-01`);
                    return sortVal === 'Most Recent' ? dateB - dateA : dateA - dateB;
                });
            }
            const list = document.getElementById('game-list');
            list.innerHTML = '';
            filtered.forEach(g => {
                const card = document.createElement('div');
                card.className = 'game-card';
                const coverUri = (g.assets['cover-tiny'].uri || '').replace(/^http:/, 'https:');
                card.innerHTML = `<img src="${coverUri}" alt="${g.names.international}">
                    <div><h3>${g.names.international}</h3><p>${g.releaseDate || g.released} (${relativeTime(g)})</p></div>`;
                card.addEventListener('click', () => navigate(`game/${g.id}/fullgame`));
                list.appendChild(card);
            });
        }

        // Render Full Game Leaderboard
        async function renderFullGameLeaderboard(content, gameId) {
            content.innerHTML = `<h2>${currentGame.names.international} - Full Game</h2>`;
            const cats = await fetchGameData(gameId, 'categories');
            const vars = await fetchGameData(gameId, 'variables');
            const fullCats = cats.filter(c => c.type === 'per-game');
            const selectCat = document.createElement('select');
            fullCats.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.text = c.name;
                if (c.id === currentCat) opt.selected = true;
                selectCat.appendChild(opt);
            });
            selectCat.onchange = () => navigate(`game/${gameId}/fullgame/${selectCat.value}`);
            content.appendChild(selectCat);

            // Subcategories
            const fullVars = vars.filter(v => v['is-subcategory'] && (v.scope.type === 'full-game' || v.scope.type === 'all'));
            if (fullVars.length) {
                const selectSub = document.createElement('select');
                Object.entries(fullVars[0].values.values).forEach(([id, val]) => {
                    const opt = document.createElement('option');
                    opt.value = `${fullVars[0].id}-${id}`;
                    opt.text = val.label;
                    if (opt.value === currentSub) opt.selected = true;
                    selectSub.appendChild(opt);
                });
                selectSub.onchange = () => navigate(`game/${gameId}/fullgame/${currentCat}/${selectSub.value}`);
                content.appendChild(selectSub);
            }

            renderLeaderboardTable(content, gameId, 'fullgame', currentCat, currentSub);
            const btn = document.createElement('button');
            btn.textContent = 'Submit Run';
            btn.addEventListener('click', () => openModal('fullgame', currentCat, currentSub));
            content.appendChild(btn);
        }

        // Render Level Leaderboard
        async function renderLevelLeaderboard(content, gameId, levelId) {
            content.innerHTML = `<h2>${currentGame.names.international} - Levels</h2>`;
            const levels = await fetchGameData(gameId, 'levels');
            const levelSelect = document.createElement('select');
            levels.forEach(l => {
                const opt = document.createElement('option');
                opt.value = l.id;
                opt.text = l.name;
                if (l.id === levelId) opt.selected = true;
                levelSelect.appendChild(opt);
            });
            levelSelect.onchange = () => navigate(`game/${gameId}/level/${levelSelect.value}/${currentCat}/${currentSub}`);
            content.appendChild(levelSelect);

            const cats = await fetchGameData(gameId, 'categories');
            const levelCats = cats.filter(c => c.type === 'per-level');
            const catSelect = document.createElement('select');
            levelCats.forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.text = c.name;
                if (c.id === currentCat) opt.selected = true;
                catSelect.appendChild(opt);
            });
            catSelect.onchange = () => navigate(`game/${gameId}/level/${levelId}/${catSelect.value}/${currentSub}`);
            content.appendChild(catSelect);

            // Single Star dropdown
            const isSingleStar = levelCats.find(c => c.id === currentCat && c.name.includes('Single Star'));
            if (isSingleStar) {
                const vars = await fetchGameData(gameId, 'variables');
                const levelVars = vars.filter(v => v['is-subcategory'] && v.scope.type === 'single-level' && v.scope.level === levelId);
                if (levelVars.length) {
                    const starSelect = document.createElement('select');
                    Object.entries(levelVars[0].values.values).forEach(([id, val]) => {
                        const opt = document.createElement('option');
                        opt.value = `${levelVars[0].id}-${id}`;
                        opt.text = val.label;
                        if (opt.value === currentSub) opt.selected = true;
                        starSelect.appendChild(opt);
                    });
                    starSelect.onchange = () => navigate(`game/${gameId}/level/${levelId}/${currentCat}/${starSelect.value}`);
                    content.appendChild(starSelect);
                }
            }

            renderLeaderboardTable(content, gameId, `level-${levelId}`, currentCat, currentSub);
            const btn = document.createElement('button');
            btn.textContent = 'Submit Run';
            btn.addEventListener('click', () => openModal(`level-${levelId}`, currentCat, currentSub));
            content.appendChild(btn);
        }

        // Render Leaderboard Table
        function renderLeaderboardTable(content, gameId, type, catId, sub) {
            const table = document.createElement('table');
            table.innerHTML = `<tr><th>#</th><th>Player</th><th>Time</th><th>Date</th><th>Video</th></tr>`;
            content.appendChild(table);
            const path = `runs/${gameId}/${type}/${catId}/${sub || 'default'}`;
            onValue(ref(db, path), snapshot => {
                const runs = [];
                snapshot.forEach(child => {
                    const run = child.val();
                    if (run.approved) runs.push(run);
                });
                runs.sort((a,b) => a.time - b.time);
                table.innerHTML = `<tr><th>#</th><th>Player</th><th>Time</th><th>Date</th><th>Video</th></tr>`;
                runs.forEach((run, i) => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${i+1}</td><td>${run.player}</td><td>${formatTime(run.time)}</td><td>${run.date}</td><td><a href="${run.video}">Link</a></td>`;
                    table.appendChild(tr);
                });
            });
        }

        // Submit Run Modal
        function openModal(type, cat, sub) {
            currentType = type;
            currentCat = cat;
            currentSub = sub;
            document.getElementById('modal').style.display = 'flex';
        }
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }
        async function submitRun() {
            const player = document.getElementById('player').value;
            const timeStr = document.getElementById('time').value;
            const video = document.getElementById('video').value;
            const date = document.getElementById('date').value;
            if (!player || !timeStr || !video || !date) return alert('Fill all fields');
            const time = parseTime(timeStr);
            const run = { gameId: currentGame.id, type: currentType, cat: currentCat, sub: currentSub || 'default', player, time, video, date, approved: false };
            const newRef = push(ref(db, 'pending_runs'));
            await set(newRef, run);
            closeModal();
            alert('Run submitted for approval');
        }

        // Render Mod Page
        function renderMod(content) {
            if (!user) {
                content.innerHTML = `<h2>Mod Login</h2>
                    <input id="email" placeholder="Email">
                    <input id="password" type="password" placeholder="Password">
                    <button id="login-btn">Login</button>
                    <button id="signup-btn">Sign Up (For Testing)</button>`;
                document.getElementById('login-btn').addEventListener('click', login);
                document.getElementById('signup-btn').addEventListener('click', signup);
                return;
            }
            content.innerHTML = `<h2>Moderation Panel</h2><button id="logout-btn">Logout</button>`;
            document.getElementById('logout-btn').addEventListener('click', logout);
            const table = document.createElement('table');
            table.innerHTML = `<tr><th>Game</th><th>Player</th><th>Time</th><th>Video</th><th>Date</th><th>Actions</th></tr>`;
            content.appendChild(table);
            onValue(ref(db, 'pending_runs'), snapshot => {
                table.innerHTML = `<tr><th>Game</th><th>Player</th><th>Time</th><th>Video</th><th>Date</th><th>Actions</th></tr>`;
                snapshot.forEach(child => {
                    const run = child.val();
                    const gameName = games.find(g => g.id === run.gameId)?.names.international || 'Unknown';
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${gameName}</td><td>${run.player}</td><td>${formatTime(run.time)}</td><td><a href="${run.video}">Link</a></td><td>${run.date}</td>`;
                    const actions = document.createElement('td');
                    const approveBtn = document.createElement('button');
                    approveBtn.textContent = 'Approve';
                    approveBtn.addEventListener('click', () => approveRun(child.key, run));
                    actions.appendChild(approveBtn);
                    const rejectBtn = document.createElement('button');
                    rejectBtn.textContent = 'Reject';
                    rejectBtn.addEventListener('click', () => remove(ref(db, `pending_runs/${child.key}`)));
                    actions.appendChild(rejectBtn);
                    const editBtn = document.createElement('button');
                    editBtn.textContent = 'Edit';
                    editBtn.addEventListener('click', () => editRun(child.key, run));
                    actions.appendChild(editBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.addEventListener('click', () => remove(ref(db, `pending_runs/${child.key}`)));
                    actions.appendChild(deleteBtn);
                    tr.appendChild(actions);
                    table.appendChild(tr);
                });
            });
        }

        async function approveRun(key, run) {
            run.approved = true;
            const path = `runs/${run.gameId}/${run.type}/${run.cat}/${run.sub}`;
            const newRef = push(ref(db, path));
            await set(newRef, run);
            await remove(ref(db, `pending_runs/${key}`));
        }

        function editRun(key, run) {
            const newPlayer = prompt('New Player', run.player);
            const newTimeStr = prompt('New Time (mm:ss.ms)', formatTime(run.time).replace(/m |s /g, ':').replace('ms', ''));
            const newVideo = prompt('New Video URL', run.video);
            const newDate = prompt('New Date (YYYY-MM-DD)', run.date);
            if (newPlayer && newTimeStr && newVideo && newDate) {
                const newTime = parseTime(newTimeStr);
                update(ref(db, `pending_runs/${key}`), {
                    player: newPlayer,
                    time: newTime,
                    video: newVideo,
                    date: newDate
                });
            }
        }

        async function login() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                const cred = await signInWithEmailAndPassword(auth, email, password);
                user = cred.user;
                renderMod(document.getElementById('content'));
            } catch (e) {
                alert('Login failed: ' + e.message);
            }
        }

        async function signup() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                alert('Signed up');
            } catch (e) {
                alert('Signup failed: ' + e.message);
            }
        }

        function logout() {
            auth.signOut();
            user = null;
            renderMod(document.getElementById('content'));
        }

        // Init
        auth.onAuthStateChanged(u => {
            user = u;
            if (window.location.hash === '#mod') renderMod(document.getElementById('content'));
        });
        window.onhashchange = renderPage;
        document.getElementById('home-btn').addEventListener('click', () => navigate('home'));
        document.getElementById('mod-btn').addEventListener('click', () => navigate('mod'));
        document.getElementById('submit-btn').addEventListener('click', submitRun);
        document.getElementById('close-btn').addEventListener('click', closeModal);
        renderPage();
    </script>
</body>
</html>
