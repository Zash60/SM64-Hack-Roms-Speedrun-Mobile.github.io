<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM64 Hack Roms Speedrun Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <style>
        :root {
            --bg-color: #1a1a1a; --surface-color: #2c2c2c; --primary-color: #4a90e2;
            --text-color: #e0e0e0; --text-secondary-color: #a0a0e0; --border-color: #444;
        }
        body { font-family: 'Roboto', sans-serif; margin: 0; background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 20px; }
        a { color: var(--primary-color); text-decoration: none; cursor: pointer; transition: color 0.2s ease; }
        a:hover { color: #8bb9f2; text-decoration: underline; }
        header { background-color: var(--surface-color); padding: 1rem 0; border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 999; }
        header .container { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
        header nav a { margin-left: 15px; font-weight: bold; }
        h1, h2, h3, h4 { font-weight: 700; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 0; }
        h4 { font-size: 1.1em; margin-top: 20px; border-bottom: none; padding-bottom: 4px; border-left: 3px solid var(--primary-color); padding-left: 10px;}
        h5 { margin-bottom: 5px; color: var(--text-secondary-color); font-size: 0.9em; text-transform: uppercase; }
        .card { background-color: var(--surface-color); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid var(--border-color); }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, select, textarea, button { font-family: 'Roboto', sans-serif; font-size: 1rem; }
        input, select, textarea { width: 100%; padding: 10px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color); box-sizing: border-box; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        input:focus, select:focus, textarea:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2); outline: none; }
        input[readonly] { background-color: #333; cursor: not-allowed; }
        input[type="checkbox"] { width: auto; margin-right: 10px; }
        select { appearance: none; -webkit-appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a0a0a0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right .7em top 50%; background-size: .65em auto; padding-right: 2em; }
        .btn { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-right: 5px; transition: background-color 0.2s ease, transform 0.1s ease; }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(0px); }
        .btn:disabled { background-color: #555; cursor: not-allowed; transform: none; }
        .btn-sm { padding: 5px 8px; font-size: 0.8em; }
        .btn-primary { background-color: var(--primary-color); color: #fff; }
        .btn-primary:hover { background-color: #5a9ee4; }
        .btn-success { background-color: #28a745; color: #fff; }
        .btn-success:hover { background-color: #32c453; }
        .btn-danger { background-color: #dc3545; color: #fff; }
        .btn-danger:hover { background-color: #e44d5c; }
        .btn-icon { background: none; border: none; color: var(--text-secondary-color); cursor: pointer; padding: 2px 6px; font-size: 1.1em; transition: color 0.2s ease; }
        .btn-icon:hover { color: var(--primary-color); transform: none; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); animation: fadeIn 0.3s; }
        .modal-content { background-color: var(--surface-color); margin: 5% auto; padding: 20px; border: 1px solid var(--border-color); width: 90%; max-width: 700px; border-radius: 8px; animation: fadeIn 0.4s ease-out; position: relative; }
        .close-button { position: absolute; top: 10px; right: 15px; color: #aaa; font-size: 32px; font-weight: bold; cursor: pointer; line-height: 1; padding: 5px; transition: color 0.2s ease; }
        .close-button:hover, .close-button:focus { color: #fff; text-decoration: none; }
        .page-container { padding: 2rem 0; animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .games-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; }
        .game-card { display: block; background-color: var(--surface-color); border-radius: 8px; overflow: hidden; text-align: center; border: 1px solid var(--border-color); transition: transform 0.2s ease, box-shadow 0.2s ease; animation: fadeIn 0.5s ease-out forwards; opacity: 0; }
        .game-card:hover { transform: translateY(-5px); box-shadow: 0 8px 15px rgba(0,0,0,0.3); }
        .game-card img { width: 100%; height: 80px; object-fit: contain; display: block; background-color: #111; }
        .game-card-info { padding: 10px; }
        .game-card-info h3 { margin: 0; font-size: 0.8rem; font-weight: 400; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: none; padding: 0;}
        .game-card-year { position: absolute; top: 5px; right: 5px; background-color: rgba(0,0,0,0.7); color: white; padding: 2px 5px; border-radius: 3px; font-size: 0.7em; font-weight: bold; }
        .game-card-runs { position: absolute; bottom: 5px; left: 5px; background-color: rgba(0,0,0,0.7); color: white; padding: 2px 5px; border-radius: 3px; font-size: 0.7em; }
        .leaderboard-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
        .leaderboard-nav { display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-end; }
        .category-tabs { display: flex; gap: 5px; flex-wrap: wrap; }
        .tab { padding: 8px 15px; background-color: #333; border-radius: 5px; cursor: pointer; border: 1px solid var(--border-color); transition: all 0.2s ease; }
        .tab.active, .tab:hover { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .leaderboard-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        .leaderboard-table th, .leaderboard-table td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border-color); }
        .hack-item-header { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 10px; flex-wrap: wrap; }
        .hack-manage-details { display: none; width: 100%; padding: 15px; background-color: #222; border-top: 1px solid var(--border-color); margin-top: 10px; border-radius: 0 0 8px 8px; }
        .admin-list-item { display: flex; justify-content: space-between; align-items: center; gap: 10px; padding: 5px 0; border-bottom: 1px solid #333; flex-wrap: wrap; }
        .inline-edit-container { display: flex; align-items: center; gap: 5px; flex-grow: 1; }
        .inline-edit-container input { width: auto; flex-grow: 1; padding: 4px; font-size: 0.9em; background-color: #111; }
        .admin-add-form { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
        .admin-add-form input { flex-grow: 1; min-width: 150px; }
        .admin-add-form button { flex-shrink: 0; }
        .controls-container { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;}
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; }
        .video-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin-top: 10px; }
        .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .status-badge { padding: 3px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; color: white; }
        .status-approved { background-color: #28a745; }
        .status-pending { background-color: #fd7e14; }
        .status-rejected { background-color: #dc3545; }
        .status-obsolete { background-color: #6c757d; }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>SM64 Hack Roms Speedrun Mobile</h1>
            <nav><a id="home-link">Home</a><span id="auth-links-container"></span></nav>
        </div>
    </header>
    <main class="container">
        <div id="page-home" class="page-container">
            <h2>Games</h2>
            <div class="controls-container">
                <div class="form-group" style="flex-grow: 1;"><label for="hack-search-input">Search</label><input type="search" id="hack-search-input"></div>
                <div class="form-group"><label for="sort-by-select">Sort by</label>
                    <select id="sort-by-select">
                        <option value="name_asc">Name</option>
                        <option value="newest_released">Newest released</option>
                        <option value="oldest_released">Oldest released</option>
                    </select>
                </div>
            </div>
            <div id="games-grid"></div>
        </div>
        <div id="page-hack-details" class="page-container" style="display: none;">
            <div class="leaderboard-header">
                <h2 id="hack-details-title"></h2>
                <button id="submit-run-btn" class="btn btn-primary">Submit Run</button>
            </div>
            <div class="leaderboard-nav">
                <div class="form-group"><label>Leaderboard Type</label><select id="type-select"></select></div>
                <div id="level-select-container" class="form-group" style="display: none;"><label>Level / Stage</label><select id="level-select"></select></div>
            </div>
            <div id="leaderboard-content"></div>
        </div>
        <div id="page-admin" class="page-container" style="display: none;">
            <div id="login-section" style="display:none;">
                <h2>Moderator Login</h2>
                <form id="login-form" class="card">
                    <div class="form-group"><label>Email</label><input type="email" id="email" required></div>
                    <div class="form-group"><label>Password</label><input type="password" id="password" required></div>
                    <button type="submit" class="btn btn-primary">Login</button>
                    <p id="login-error" style="color: #e24a4a;"></p>
                </form>
            </div>
            <div id="admin-content" style="display: none;">
                <h2>Admin Panel</h2>
                <div class="card">
                    <h3>Review Pending Runs</h3>
                    <div id="pending-runs-list"></div>
                </div>
                <div class="card">
                    <h3>Existing Hack Roms</h3>
                    <div id="existing-hacks-list"></div>
                </div>
                <div class="card">
                    <h3>Add New Hack Rom</h3>
                    <form id="add-hack-form">
                        <div class="form-group"><label>Hack Name</label><input type="text" id="add-hack-name" required></div>
                        <div class="form-group"><label>Release Year</label><input type="number" id="add-hack-year" required></div>
                        <div class="form-group"><label>Cover Image URL</label><input type="url" id="add-hack-image" placeholder="https://example.com/image.png" required></div>
                        <button type="submit" class="btn btn-primary">Add Hack</button>
                    </form>
                </div>
                <div class="card">
                    <h3>Synchronization</h3>
                    <p>Fetch and add new SM64 Hack Roms, including categories and levels, directly from the official speedrun.com series.</p>
                    <button id="sync-src-btn" class="btn btn-primary">Sync with Speedrun.com</button>
                    <div class="form-group" style="margin-top: 10px;"><label style="display: inline-flex; align-items: center;"><input type="checkbox" id="force-sync-checkbox"> Force update (deletes all existing data)</label></div>
                    <div id="sync-status" style="margin-top: 10px;"></div>
                </div>
            </div>
        </div>
        <div id="page-profile" class="page-container" style="display: none;">
            <h2 id="profile-welcome">Your Runs</h2>
            <div class="card">
                <h4>Personal Bests</h4>
                <div id="profile-runs-approved"></div>
            </div>
            <div class="card">
                <h4>Pending Review</h4>
                <div id="profile-runs-pending"></div>
            </div>
             <div class="card">
                <h4>Rejected & Obsolete</h4>
                <div id="profile-runs-rejected"></div>
            </div>
        </div>
    </main>
    <div id="submit-run-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3><span id="modal-action-title">Submit</span> Run for <span id="submit-run-hack-name"></span></h3>
            <div id="submit-run-category-name"></div>
            <hr style="border-color: var(--border-color); margin: 15px 0;">
            <form id="submit-run-form">
                <div id="run-submission-filters"></div>
                <div class="form-group"><label>Player Name</label><input type="text" id="run-player" required readonly></div>
                <div class="form-group"><label>Time (e.g., 1:23.456)</label><input type="text" id="run-time" required></div>
                <div class="form-group"><label>Date Achieved</label><input type="date" id="run-date" required></div>
                <div class="form-group"><label>Video Link</label><input type="url" id="run-video" required></div>
                <button type="submit" class="btn btn-primary" id="modal-submit-btn">Submit for Review</button>
            </form>
        </div>
    </div>
    <div id="register-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3>Register New Account</h3>
            <form id="register-form">
                <div class="form-group"><label>Username</label><input type="text" id="register-username" required></div>
                <div class="form-group"><label>Email</label><input type="email" id="register-email" required></div>
                <div class="form-group"><label>Password</label><input type="password" id="register-password" required></div>
                <button type="submit" class="btn btn-primary">Register</button>
                <p id="register-error" style="color: #e24a4a;"></p>
            </form>
        </div>
    </div>
    <div id="login-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h3>User Login</h3>
            <form id="user-login-form">
                <div class="form-group"><label>Email</label><input type="email" id="user-login-email" required></div>
                <div class="form-group"><label>Password</label><input type="password" id="user-login-password" required></div>
                <button type="submit" class="btn btn-primary">Login</button>
                <p id="user-login-error" style="color: #e24a4a;"></p>
            </form>
        </div>
    </div>

<script type="module">
    // Import Firebase SDKs
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, updateProfile } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getDatabase, ref, get, set, push, remove, update, query, orderByChild, equalTo, onValue } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyAsVYnWAq5aFOz9dIxHpGVWK8Mk64f01GU",
        authDomain: "sm64-hack-roms-speedrun-mobile.firebaseapp.com",
        databaseURL: "https://sm64-hack-roms-speedrun-mobile-default-rtdb.firebaseio.com",
        projectId: "sm64-hack-roms-speedrun-mobile",
        storageBucket: "sm64-hack-roms-speedrun-mobile.firebasestorage.app",
        messagingSenderId: "499101981060",
        appId: "1:499101981060:web:209dfe3f20866ef4f865d1"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    let state = { user: null, editingRunId: null };

    // --- Utility Functions ---
    function showPage(pageId) { document.querySelectorAll('.page-container').forEach(p => p.style.display = 'none'); document.getElementById(pageId).style.display = 'block'; }
    function parseTimeToMilliseconds(timeStr) { let t=0;if(timeStr.includes(':')){const parts=timeStr.split(':').reverse();t+=parseFloat(parts[0]||0)*1e3;t+=parseInt(parts[1]||0)*6e4;t+=parseInt(parts[2]||0)*36e5}else{timeStr.match(/(\d+)\s*h/)?.[1]&&(t+=parseInt(timeStr.match(/(\d+)\s*h/)[1])*36e5);timeStr.match(/(\d+)\s*m/)?.[1]&&(t+=parseInt(timeStr.match(/(\d+)\s*m/)[1])*6e4);timeStr.match(/(\d+(\.\d+)?)\s*s/)?.[1]&&(t+=parseFloat(timeStr.match(/(\d+(\.\d+)?)\s*s/)[1].replace(",","."))*1e3);timeStr.match(/(\d+)\s*ms/)?.[1]&&(t+=parseInt(timeStr.match(/(\d+)\s*ms/)[1]))}if(t===0&&!isNaN(parseFloat(timeStr)))t=parseFloat(timeStr)*1e3;return Math.round(t)}
    function formatTime(ms) { if (isNaN(ms) || ms < 0) return "Invalid Time"; const tS = Math.floor(ms / 1000); const h = Math.floor(tS / 3600); const m = Math.floor((tS % 3600) / 60); const s = tS % 60; const mmm = ms % 1000; const pM = String(m).padStart(2, '0'); const pS = String(s).padStart(2, '0'); const pMMM = String(mmm).padStart(3, '0'); if (h > 0) { return `${h}:${pM}:${pS}.${pMMM}`; } return `${m}:${pS}.${pMMM}`; }
    function createHTMLElement(tag, className, innerHTML = '') { const el = document.createElement(tag); if (className) el.className = className; el.innerHTML = innerHTML; return el; }
    function slugify(text) { return text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, ''); }
    function snapshotToArray(snapshot) {
        const returnArr = [];
        snapshot.forEach(childSnapshot => {
            const item = childSnapshot.val();
            item.id = childSnapshot.key;
            returnArr.push(item);
        });
        return returnArr;
    }
    function getVideoEmbedUrl(url) {
        if (!url) return null;
        try {
            if (url.includes('youtube.com/watch?v=')) { const videoId = new URL(url).searchParams.get('v'); return `https://www.youtube.com/embed/${videoId}`; }
            if (url.includes('youtu.be/')) { const videoId = new URL(url).pathname.slice(1); return `https://www.youtube.com/embed/${videoId}`; }
        } catch (e) { console.error("Invalid video URL", e); return null; }
        return null;
    }
    function generatePBKey(run) {
        const sortedVars = Object.keys(run.variables || {}).sort().map(key => `${key}=${run.variables[key]}`).join('&');
        return `${run.userId}_${run.category_id}_${sortedVars}`;
    }

    // --- Main Logic & Routing ---
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('home-link').onclick = (e) => { e.preventDefault(); window.location.hash = ''; showPage('page-home'); };
        document.querySelectorAll('.modal .close-button').forEach(btn => {
            btn.onclick = () => { btn.closest('.modal').style.display = 'none'; };
        });
        onAuthStateChanged(auth, user => {
            state.user = user;
            updateAuthUI();
            handleRouteChange();
        });
    });
    
    function updateAuthUI() {
        const authLinks = document.getElementById('auth-links-container');
        if (state.user) {
            authLinks.innerHTML = `<a id="profile-link">Profile</a><a id="admin-link">Admin</a><a id="logout-link">Logout</a>`;
            document.getElementById('profile-link').onclick = (e) => { e.preventDefault(); window.location.hash = '#profile'; };
            document.getElementById('admin-link').onclick = (e) => { e.preventDefault(); window.location.hash = '#admin'; };
            document.getElementById('logout-link').onclick = async (e) => { e.preventDefault(); await signOut(auth); window.location.hash = ''; };
        } else {
            authLinks.innerHTML = `<a id="login-link">Login</a><a id="register-link">Register</a><a id="admin-link">Admin</a>`;
            document.getElementById('login-link').onclick = (e) => { e.preventDefault(); document.getElementById('login-modal').style.display = 'block'; };
            document.getElementById('register-link').onclick = (e) => { e.preventDefault(); document.getElementById('register-modal').style.display = 'block'; };
            document.getElementById('admin-link').onclick = (e) => { e.preventDefault(); window.location.hash = '#admin'; };
        }
    }

    window.addEventListener('hashchange', handleRouteChange);
    function handleRouteChange() {
        const hash = window.location.hash;
        if (hash.startsWith('#hack/')) showHackDetails(hash.substring(6));
        else if (hash === '#admin') { showPage('page-admin'); initAdminPage(); }
        else if (hash === '#profile') { showProfilePage(); }
        else { showPage('page-home'); if (!document.querySelector('#games-grid .game-card')) fetchAndDisplayHacks(); }
    }

    async function fetchAndDisplayHacks() {
        const gamesGrid = document.getElementById('games-grid');
        gamesGrid.innerHTML = '<div class="loader"></div>';
        const runsSnapshot = await get(ref(db, 'runs'));
        const runs = runsSnapshot.exists() ? snapshotToArray(runsSnapshot) : [];
        const runCounts = runs.reduce((acc, run) => {
            if (run.status === 'approved') { acc[run.hack_id] = (acc[run.hack_id] || 0) + 1; }
            return acc;
        }, {});
        const sortBy = document.getElementById('sort-by-select').value;
        let sortKey = 'name';
        if (sortBy === 'newest_released' || sortBy === 'oldest_released') { sortKey = 'year'; }
        const q = query(ref(db, 'hacks'), orderByChild(sortKey));
        try {
            const snapshot = await get(q);
            let hacks = snapshot.exists() ? snapshotToArray(snapshot) : [];
            if (sortBy === 'newest_released') { hacks.sort((a, b) => (b.year || 0) - (a.year || 0) || (b.created_at || '').localeCompare(a.created_at || '')); } 
            else if (sortBy === 'oldest_released') { hacks.sort((a, b) => (a.year || 0) - (b.year || 0) || (a.created_at || '').localeCompare(b.created_at || ''));}
            gamesGrid.innerHTML = '';
            if (hacks.length === 0) { gamesGrid.innerHTML = '<p>No hack roms found. Run the sync in the Admin Panel.</p>'; return; }
            hacks.forEach((hack, index) => {
                const count = runCounts[hack.id] || 0;
                const card = createHTMLElement('a', 'game-card', `<div class="game-card-year">${hack.year || ''}</div><img src="${hack.imageUrl}" alt="${hack.name}" loading="lazy"><div class="game-card-info"><h3>${hack.name}</h3></div><div class="game-card-runs"><i class="fas fa-trophy"></i> ${count}</div>`);
                card.style.animationDelay = `${index * 0.05}s`;
                card.href = `#hack/${hack.slug}`;
                card.onclick = (e) => { e.preventDefault(); window.location.hash = `hack/${hack.slug}`; };
                gamesGrid.appendChild(card);
            });
        } catch (error) {
            console.error("Error fetching hacks:", error);
            gamesGrid.innerHTML = `<p style="color: red;"><b>Error loading games.</b><br>Check Firebase setup and RTDB security rules.</p>`;
        }
    }
    
    document.getElementById('hack-search-input').addEventListener('input', (e) => { const searchTerm = e.target.value.toLowerCase(); document.querySelectorAll('.game-card').forEach(card => { card.style.display = card.querySelector('h3').textContent.toLowerCase().includes(searchTerm) ? 'block' : 'none'; }); });
    document.getElementById('sort-by-select').addEventListener('change', fetchAndDisplayHacks);

    async function showHackDetails(slug) {
        showPage('page-hack-details');
        const leaderboardContent = document.getElementById('leaderboard-content');
        leaderboardContent.innerHTML = '<div class="loader"></div>';
        const snapshot = await get(ref(db, `hacks/${slug}`));
        const hack = snapshot.exists() ? { id: snapshot.key, ...snapshot.val() } : null;
        if (!hack) { window.location.hash = ''; return; }
        leaderboardContent.innerHTML = `<div id="category-tabs-container"><h4>Categories</h4><div class="category-tabs"></div></div><div id="variable-filters"></div><table class="leaderboard-table"><thead><tr><th>#</th><th>Player</th><th>Time</th><th>Date</th><th id="actions-header" style="display:none;">Actions</th></tr></thead><tbody></tbody></table>`;
        state.hack = hack;
        document.getElementById('hack-details-title').textContent = hack.name;
        document.getElementById('type-select').innerHTML = '<option value="fullgame">Full-game</option><option value="level_rta">Level RTA</option><option value="level_singlestar">Single-Star</option>';
        const levelsQ = query(ref(db, 'levels'), orderByChild('hack_id'), equalTo(hack.id));
        const levelsSnapshot = await get(levelsQ);
        const levels = levelsSnapshot.exists() ? snapshotToArray(levelsSnapshot).sort((a,b) => a.order - b.order) : [];
        document.getElementById('level-select').innerHTML = levels ? levels.map(l => `<option value="${l.id}">${l.name}</option>`).join('') : '';
        [document.getElementById('level-select'), document.getElementById('type-select')].forEach(el => el.onchange = renderLeaderboardUI);
        renderLeaderboardUI();
    }
    
    async function renderLeaderboardUI() {
        const selectedType = document.getElementById('type-select').value; 
        const isFullgame = selectedType === 'fullgame';
        document.getElementById('level-select-container').style.display = isFullgame ? 'none' : 'block';
        document.getElementById('leaderboard-content').querySelector('#category-tabs-container').style.display = isFullgame ? 'block' : 'none';
        const categoriesQ = query(ref(db, 'categories'), orderByChild('hack_id'), equalTo(state.hack.id));
        const snapshot = await get(categoriesQ);
        const allCategories = snapshot.exists() ? snapshotToArray(snapshot) : [];
        const categories = allCategories.filter(c => c.type === selectedType).sort((a,b) => a.order - b.order);
        if (categories.length === 0) { document.querySelector('.leaderboard-table tbody').innerHTML = `<tr><td colspan="4">No categories for this type.</td></tr>`; document.getElementById('variable-filters').innerHTML = ''; return; }
        if (isFullgame) {
            const tabsContainer = document.querySelector('.category-tabs');
            tabsContainer.innerHTML = categories.map(c => `<div class="tab" data-id="${c.id}">${c.name}</div>`).join('');
            tabsContainer.querySelectorAll('.tab').forEach(tab => tab.onclick = () => { tabsContainer.querySelector('.active')?.classList.remove('active'); tab.classList.add('active'); renderVariablesAndRuns(categories.find(c => c.id === tab.dataset.id)); });
            tabsContainer.querySelector('.tab').click();
        } else { renderVariablesAndRuns(categories[0]); }
    }
    
    async function renderVariablesAndRuns(category) {
        state.category = category;
        const filtersContainer = document.getElementById('variable-filters');
        filtersContainer.innerHTML = '';
        if (category.type === 'fullgame') {
            const variablesQ = query(ref(db, 'variables'), orderByChild('hack_id'), equalTo(state.hack.id));
            const variablesSnapshot = await get(variablesQ);
            const allVariables = variablesSnapshot.exists() ? snapshotToArray(variablesSnapshot) : [];
            const relevantVariables = allVariables.filter(v => !v.category_id || v.category_id === category.id).sort((a,b) => a.order - b.order);
            for(const v of relevantVariables) {
                const optionsQ = query(ref(db, 'options'), orderByChild('variable_id'), equalTo(v.id));
                const optionsSnapshot = await get(optionsQ);
                v.options = optionsSnapshot.exists() ? snapshotToArray(optionsSnapshot).sort((a,b) => a.order - b.order) : [];
            }
            filtersContainer.innerHTML = relevantVariables.map(v => `<div class="form-group"><label>${v.name}</label><select data-var-id="${v.id}">${v.options.map(opt => `<option value="${opt.id}">${opt.name}</option>`).join('')}</select></div>`).join('');
        } else if (category.type === 'level_singlestar') {
            const levelId = document.getElementById('level-select').value;
            const starsQ = query(ref(db, 'stars'), orderByChild('level_id'), equalTo(levelId));
            const starsSnapshot = await get(starsQ);
            const stars = starsSnapshot.exists() ? snapshotToArray(starsSnapshot).sort((a,b) => a.order - b.order) : [];
            if (stars.length > 0) { filtersContainer.innerHTML = `<div class="form-group"><label>Star</label><select data-var-id="star">${stars.map(s => `<option value="${s.id}">${s.name}</option>`).join('')}</select></div>`;}
        }
        document.querySelectorAll('#variable-filters select').forEach(s => s.onchange = fetchAndDisplayLeaderboard);
        fetchAndDisplayLeaderboard();
    }

    async function fetchAndDisplayLeaderboard() {
        const isMod = !!state.user;
        document.querySelector('#actions-header').style.display = isMod ? '' : 'none';
        const tbody = document.querySelector('.leaderboard-table tbody');
        tbody.innerHTML = `<tr><td colspan="${isMod ? 5 : 4}"><div class="loader"></div></td></tr>`;
        const runsQ = query(ref(db, 'runs'), orderByChild('category_id'), equalTo(state.category.id));
        const snapshot = await get(runsQ);
        const allRunsForCategory = snapshot.exists() ? snapshotToArray(snapshot) : [];
        const approvedRuns = allRunsForCategory.filter(run => run.status === 'approved');
        const variables = {};
        document.querySelectorAll('#variable-filters select').forEach(s => { variables[s.dataset.varId] = s.value; });
        if (state.category.type !== 'fullgame') variables['level'] = document.getElementById('level-select').value;
        const filteredRuns = approvedRuns.filter(run => Object.keys(variables).every(key => run.variables && run.variables[key] === variables[key])).sort((a, b) => a.timeInMs - b.timeInMs);
        tbody.innerHTML = '';
        if (filteredRuns.length === 0) { tbody.innerHTML = `<tr><td colspan="${isMod ? 5 : 4}">No approved runs for these filters.</td></tr>`; return; }
        filteredRuns.forEach((run, index) => {
            const row = tbody.insertRow();
            row.innerHTML = `<td>${index + 1}</td><td><a href="${run.videoUrl}" target="_blank">${run.playerName}</a></td><td>${formatTime(run.timeInMs)}</td><td>${run.dateAchieved}</td>`;
            if (isMod) {
                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `<button class="btn btn-primary btn-sm">Edit</button><button class="btn btn-danger btn-sm">Del</button>`;
                actionsCell.querySelector('.btn-primary').onclick = () => openEditRunModal(run);
                actionsCell.querySelector('.btn-danger').onclick = () => deleteRun(run.id);
            }
        });
    }

    // --- Admin Panel ---
    function initAdminPage() {
        document.getElementById('login-section').style.display = state.user ? 'none' : 'block';
        document.getElementById('admin-content').style.display = state.user ? 'block' : 'none';
        if (state.user) {
            loadAdminData();
            const syncBtn = document.getElementById('sync-src-btn');
            if (!syncBtn.dataset.listener) { syncBtn.addEventListener('click', syncWithSpeedrunCom); syncBtn.dataset.listener = 'true'; }
            document.getElementById('add-hack-form').onsubmit = handleAddHack;
        }
        document.getElementById('login-form').onsubmit = async (e) => {
            e.preventDefault();
            const email = e.target.querySelector('#email').value;
            const password = e.target.querySelector('#password').value;
            try { await signInWithEmailAndPassword(auth, email, password); document.getElementById('login-error').textContent = ''; } catch (error) { document.getElementById('login-error').textContent = error.message; }
        };
    }
    
    async function handleAddHack(e) {
        e.preventDefault();
        const name = document.getElementById('add-hack-name').value;
        const hackId = slugify(name);
        const newHack = { name, year: Number(document.getElementById('add-hack-year').value), imageUrl: document.getElementById('add-hack-image').value, slug: hackId, created_at: new Date().toISOString() };
        try { 
            await set(ref(db, `hacks/${hackId}`), newHack); 
            alert('Hack added!'); e.target.reset(); loadExistingHacksAdmin(); 
        } catch (error) { alert('Error: ' + error.message); }
    }

    async function loadAdminData() { await Promise.all([ loadExistingHacksAdmin(), loadPendingRuns() ]); }

    async function loadExistingHacksAdmin() {
        const listContainer = document.getElementById('existing-hacks-list');
        listContainer.innerHTML = '<div class="loader"></div>';
        const q = query(ref(db, 'hacks'), orderByChild('name'));
        const snapshot = await get(q);
        const hacks = snapshot.exists() ? snapshotToArray(snapshot) : [];
        listContainer.innerHTML = '';
        hacks.forEach(hack => {
            const item = createHTMLElement('div', 'card');
            item.innerHTML = `<div class="hack-item-header"><span><strong>${hack.name}</strong> (${hack.year || 'N/A'})</span><div><button class="btn btn-primary btn-sm manage-btn">Manage <i class="fa-solid fa-chevron-down"></i></button><button class="btn btn-danger btn-sm delete-btn">Delete</button></div></div><div class="hack-manage-details"></div>`;
            const detailsDiv = item.querySelector('.hack-manage-details'), manageBtn = item.querySelector('.manage-btn');
            
            manageBtn.onclick = () => {
                const isVisible = detailsDiv.style.display === 'block';
                detailsDiv.style.display = isVisible ? 'none' : 'block';
                manageBtn.querySelector('i').className = isVisible ? 'fa-solid fa-chevron-down' : 'fa-solid fa-chevron-up';
                if (!isVisible && detailsDiv.innerHTML === '') {
                    detailsDiv.innerHTML = '<h4>Categories</h4><div class="categories-list"></div><h4>Levels</h4><div class="levels-list"></div>';
                    loadAdminItemsInline(detailsDiv.querySelector('.categories-list'), 'categories', 'Category', 'hack_id', hack.id);
                    loadAdminItemsInline(detailsDiv.querySelector('.levels-list'), 'levels', 'Level', 'hack_id', hack.id);
                }
            };
            item.querySelector('.delete-btn').onclick = () => deleteHackAndChildren(hack.id, hack.name);
            listContainer.appendChild(item);
        });
    }

    async function loadAdminItemsInline(container, path, placeholder, parentIdColumn, parentId) {
        container.innerHTML = '<div class="loader"></div>';
        const q = query(ref(db, path), orderByChild(parentIdColumn), equalTo(parentId));
        const snapshot = await get(q);
        const data = snapshot.exists() ? snapshotToArray(snapshot).sort((a,b) => (a.name || '').localeCompare(b.name || '')) : [];
        
        container.innerHTML = `<form class="admin-add-form"><input type="text" placeholder="Add New ${placeholder}" required><button type="submit" class="btn btn-success btn-sm">Add</button></form>`;
        
        container.querySelector('form').onsubmit = async (e) => {
            e.preventDefault();
            const input = e.target.querySelector('input');
            const name = input.value;
            const newId = slugify(`${parentId}-${name}`);
            const newData = { name, [parentIdColumn]: parentId, order: 999 };
            await set(ref(db, `${path}/${newId}`), newData);
            loadAdminItemsInline(container, path, placeholder, parentIdColumn, parentId);
        };

        data.forEach(itemData => {
            const itemEl = createHTMLElement('div', 'admin-list-item');
            itemEl.innerHTML = `<div class="inline-edit-container"><span>${itemData.name}</span><input type="text" value="${itemData.name}" style="display:none;"></div><div><button class="btn-icon save-btn" style="display:none;"><i class="fa fa-save"></i></button><button class="btn-icon edit-btn"><i class="fa fa-pencil-alt"></i></button><button class="btn-icon delete-btn"><i class="fa fa-trash-alt"></i></button></div>`;
            
            const nameSpan = itemEl.querySelector('span'), input = itemEl.querySelector('input');
            const saveBtn = itemEl.querySelector('.save-btn'), editBtn = itemEl.querySelector('.edit-btn');

            const saveChanges = async () => {
                const newName = input.value.trim();
                if (newName && newName !== itemData.name) {
                    await update(ref(db, `${path}/${itemData.id}`), { name: newName });
                    nameSpan.textContent = newName;
                }
                input.style.display = 'none'; nameSpan.style.display = 'inline';
                saveBtn.style.display = 'none'; editBtn.style.display = 'inline';
            };
            
            editBtn.onclick = () => { input.style.display = 'inline-block'; nameSpan.style.display = 'none'; saveBtn.style.display = 'inline'; editBtn.style.display = 'none'; input.focus(); };
            saveBtn.onclick = saveChanges;
            input.onkeydown = (e) => { if (e.key === 'Enter') saveChanges(); };
            itemEl.querySelector('.delete-btn').onclick = async () => {
                if (confirm(`Delete '${itemData.name}'?`)) {
                    await remove(ref(db, `${path}/${itemData.id}`));
                    loadAdminItemsInline(container, path, placeholder, parentIdColumn, parentId);
                }
            };
            container.appendChild(itemEl);
        });
    }

    async function deleteHackAndChildren(hackId, hackName) {
        if (!confirm(`This will permanently delete '${hackName}' and ALL its related categories, levels, variables, options, stars, and runs.\n\nThis cannot be undone. Are you sure?`)) return;

        try {
            const deleteUpdates = {};
            deleteUpdates[`/hacks/${hackId}`] = null;
            const childPaths = ['categories', 'levels', 'variables', 'runs', 'options', 'stars'];
            for (const path of childPaths) {
                const q = query(ref(db, path), orderByChild('hack_id'), equalTo(hackId));
                const snapshot = await get(q);
                if (snapshot.exists()) {
                    snapshot.forEach(child => { deleteUpdates[`/${path}/${child.key}`] = null; });
                }
            }
            await update(ref(db), deleteUpdates);
            alert(`'${hackName}' and all its data have been deleted.`);
            loadAdminData();
        } catch (error) {
            alert('An error occurred during deletion: ' + error.message);
            console.error("Deletion error:", error);
        }
    }

    async function loadPendingRuns() {
        const listContainer = document.getElementById('pending-runs-list');
        const q = query(ref(db, 'runs'), orderByChild('status'), equalTo('pending'));
        onValue(q, (snapshot) => {
            listContainer.innerHTML = '<div class="loader"></div>';
            const runs = snapshot.exists() ? snapshotToArray(snapshot).sort((a,b) => (b.submittedAt || '').localeCompare(a.submittedAt || '')) : [];
            listContainer.innerHTML = runs.length === 0 ? 'No runs pending review.' : '';
            runs.forEach(run => {
                const embedUrl = getVideoEmbedUrl(run.videoUrl);
                const videoHTML = embedUrl ? `<div class="video-container"><iframe src="${embedUrl}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>` : '';
                const item = createHTMLElement('div', 'card', `<div><strong>${run.hackName} - ${run.categoryName}</strong><br>Player: ${run.playerName} | Time: ${formatTime(run.timeInMs)} | <a href="${run.videoUrl}" target="_blank">Video Link</a>${videoHTML}<div style="margin-top:10px;"><button class="btn btn-success approve-btn">Approve</button><button class="btn btn-danger reject-btn">Reject</button></div></div>`);
                item.querySelector('.approve-btn').onclick = () => updateRunStatus(run, 'approved');
                item.querySelector('.reject-btn').onclick = () => updateRunStatus(run, 'rejected');
                listContainer.appendChild(item);
            });
        }, { onlyOnce: false });
    }
    async function updateRunStatus(runToUpdate, newStatus) {
        const runId = runToUpdate.id;
        const updates = {};
        updates[`/runs/${runId}/status`] = newStatus;

        if (newStatus === 'approved') {
            const pb_key = generatePBKey(runToUpdate);
            updates[`/runs/${runId}/pb_key`] = pb_key;
            
            const q = query(ref(db, 'runs'), orderByChild('pb_key'), equalTo(pb_key));
            const snapshot = await get(q);
            if (snapshot.exists()) {
                const existingRuns = snapshotToArray(snapshot);
                for (const oldRun of existingRuns) {
                    if (oldRun.id !== runId && oldRun.status === 'approved') {
                        if (runToUpdate.timeInMs < oldRun.timeInMs) {
                            updates[`/runs/${oldRun.id}/status`] = 'obsolete';
                        } else {
                            updates[`/runs/${runId}/status`] = 'obsolete';
                        }
                    }
                }
            }
        }
        await update(ref(db), updates);
    }
    async function deleteRun(runId) { if (confirm(`Delete this run?`)) { await remove(ref(db, `runs/${runId}`)); fetchAndDisplayLeaderboard(); } }
    
    // --- Profile Dashboard ---
    async function showProfilePage() {
        showPage('page-profile');
        if (!state.user) { window.location.hash = ''; return; }
        document.getElementById('profile-welcome').textContent = `Welcome, ${state.user.displayName}`;
        const containers = { approved: document.getElementById('profile-runs-approved'), pending: document.getElementById('profile-runs-pending'), rejected: document.getElementById('profile-runs-rejected') };
        Object.values(containers).forEach(c => c.innerHTML = '<div class="loader"></div>');
        const q = query(ref(db, 'runs'), orderByChild('userId'), equalTo(state.user.uid));
        const snapshot = await get(q);
        const userRuns = snapshot.exists() ? snapshotToArray(snapshot).sort((a,b) => (b.submittedAt || '').localeCompare(a.submittedAt || '')) : [];
        Object.values(containers).forEach(c => c.innerHTML = 'No runs in this category.');
        userRuns.forEach(run => {
            let container;
            if (run.status === 'approved') {
                container = containers.approved;
            } else if (run.status === 'pending') {
                container = containers.pending;
            } else { 
                container = containers.rejected;
            }
            if (container) {
                if (container.innerHTML.startsWith('No runs')) container.innerHTML = '';
                const item = createHTMLElement('div', 'admin-list-item', `<span><strong><a href="#hack/${run.hack_id}">${run.hackName}</a></strong> - ${run.categoryName} (${formatTime(run.timeInMs)})</span><span class="status-badge status-${run.status}">${run.status}</span>`);
                container.appendChild(item);
            }
        });
    }

    // --- Authentication Modals ---
    document.getElementById('register-form').onsubmit = async (e) => {
        e.preventDefault();
        const username = document.getElementById('register-username').value;
        const email = document.getElementById('register-email').value;
        const password = document.getElementById('register-password').value;
        const errorP = document.getElementById('register-error');
        try {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            await updateProfile(userCredential.user, { displayName: username });
            await set(ref(db, `users/${userCredential.user.uid}`), { username });
            errorP.textContent = '';
            document.getElementById('register-modal').style.display = 'none';
        } catch (error) { errorP.textContent = error.message; }
    };
    document.getElementById('user-login-form').onsubmit = async (e) => {
        e.preventDefault();
        const email = document.getElementById('user-login-email').value;
        const password = document.getElementById('user-login-password').value;
        const errorP = document.getElementById('user-login-error');
        try {
            await signInWithEmailAndPassword(auth, email, password);
            errorP.textContent = '';
            document.getElementById('login-modal').style.display = 'none';
        } catch (error) { errorP.textContent = error.message; }
    };

    // --- Run Submission & Editing ---
    const submitRunModal = document.getElementById('submit-run-modal');
    function resetSubmitRunModal() {
        state.editingRunId = null;
        document.getElementById('modal-action-title').textContent = 'Submit';
        document.getElementById('modal-submit-btn').textContent = 'Submit for Review';
        document.getElementById('run-submission-filters').innerHTML = '';
        document.getElementById('submit-run-category-name').innerHTML = '';
        document.getElementById('submit-run-form').reset();
    }

    async function openSubmitRunModal() {
        if (!state.user) {
            alert("Please login or register to submit a run.");
            document.getElementById('login-modal').style.display = 'block';
            return;
        }
        resetSubmitRunModal();
        if (!state.hack) return;

        document.getElementById('run-player').value = state.user.displayName;
        const filtersContainer = document.getElementById('run-submission-filters');
        document.getElementById('submit-run-hack-name').textContent = state.hack.name;
        filtersContainer.innerHTML = '<div class="loader"></div>';
        
        const currentLeaderboardType = document.getElementById('type-select').value;
        const currentCategoryId = state.category?.id;
        const currentLevelId = document.getElementById('level-select').value;

        try {
            switch(currentLeaderboardType) {
                case 'fullgame': {
                    const categoriesQ = query(ref(db, 'categories'), orderByChild('hack_id'), equalTo(state.hack.id));
                    const catSnapshot = await get(categoriesQ);
                    const allCategories = catSnapshot.exists() ? snapshotToArray(catSnapshot) : [];
                    const fullGameCategories = allCategories.filter(c => c.type === 'fullgame').sort((a,b) => a.order - b.order);
                    
                    filtersContainer.innerHTML = `<div class="form-group"><label>Category</label><select id="modal-category-select">${fullGameCategories.map(c => `<option value="${c.id}" ${c.id === currentCategoryId ? 'selected' : ''}>${c.name}</option>`).join('')}</select></div><div id="modal-subcategories-container"></div>`;

                    const categorySelect = document.getElementById('modal-category-select');
                    const renderSubcategories = async () => renderSubcategoriesInModal(categorySelect.value, document.getElementById('modal-subcategories-container'));
                    categorySelect.onchange = renderSubcategories;
                    await renderSubcategories();
                    break;
                }
                case 'level_rta':
                case 'level_singlestar': {
                    const levelsQ = query(ref(db, 'levels'), orderByChild('hack_id'), equalTo(state.hack.id));
                    const levelSnapshot = await get(levelsQ);
                    const levels = levelSnapshot.exists() ? snapshotToArray(levelSnapshot).sort((a,b) => a.order - b.order) : [];
                    filtersContainer.innerHTML = `<div class="form-group"><label>Level</label><select id="modal-level-select">${levels.map(l => `<option value="${l.id}" ${l.id === currentLevelId ? 'selected' : ''}>${l.name}</option>`).join('')}</select></div><div id="modal-stars-container"></div>`;
                    
                    if (currentLeaderboardType === 'level_singlestar') {
                        const levelSelect = document.getElementById('modal-level-select');
                        const renderStars = async () => renderStarsInModal(levelSelect.value, document.getElementById('modal-stars-container'));
                        levelSelect.onchange = renderStars;
                        await renderStars();
                    }
                    break;
                }
            }
            document.getElementById('run-date').value = new Date().toISOString().split('T')[0];
            submitRunModal.style.display = 'block';
        } catch (error) {
            console.error("Error building submission modal:", error);
            filtersContainer.innerHTML = '<p style="color:red;">Could not load submission options.</p>';
        }
    }

    async function renderSubcategoriesInModal(categoryId, container) {
        container.innerHTML = '<div class="loader"></div>';
        const variablesQ = query(ref(db, 'variables'), orderByChild('hack_id'), equalTo(state.hack.id));
        const variablesSnapshot = await get(variablesQ);
        const allVariables = variablesSnapshot.exists() ? snapshotToArray(variablesSnapshot) : [];
        const relevantVariables = allVariables.filter(v => !v.category_id || v.category_id === categoryId).sort((a,b) => a.order - b.order);
        let html = '';
        for(const v of relevantVariables) {
            const optionsQ = query(ref(db, 'options'), orderByChild('variable_id'), equalTo(v.id));
            const optionsSnapshot = await get(optionsQ);
            const options = optionsSnapshot.exists() ? snapshotToArray(optionsSnapshot).sort((a,b) => a.order - b.order) : [];
            html += `<div class="form-group"><label>${v.name}</label><select data-var-id="${v.id}">${options.map(opt => `<option value="${opt.id}">${opt.name}</option>`).join('')}</select></div>`;
        }
        container.innerHTML = html;
    }

    async function renderStarsInModal(levelId, container) {
        container.innerHTML = '<div class="loader"></div>';
        const starsQ = query(ref(db, 'stars'), orderByChild('level_id'), equalTo(levelId));
        const starsSnapshot = await get(starsQ);
        const stars = starsSnapshot.exists() ? snapshotToArray(starsSnapshot).sort((a,b) => a.order - b.order) : [];
        if (stars.length > 0) {
            container.innerHTML = `<div class="form-group"><label>Star</label><select data-var-id="star">${stars.map(s => `<option value="${s.id}">${s.name}</option>`).join('')}</select></div>`;
        } else { container.innerHTML = ''; }
    }

    function openEditRunModal(run) {
        resetSubmitRunModal();
        state.editingRunId = run.id;
        document.getElementById('modal-action-title').textContent = 'Edit';
        document.getElementById('submit-run-hack-name').textContent = run.hackName;
        document.getElementById('submit-run-category-name').innerHTML = `<h4>${run.categoryName}</h4>`;
        document.getElementById('modal-submit-btn').textContent = 'Save Changes';
        document.getElementById('run-player').value = run.playerName;
        document.getElementById('run-time').value = formatTime(run.timeInMs);
        document.getElementById('run-date').value = run.dateAchieved;
        document.getElementById('run-video').value = run.videoUrl;
        submitRunModal.style.display = 'block';
    }

    document.getElementById('submit-run-btn').onclick = openSubmitRunModal;
    document.querySelector('#submit-run-modal .close-button').onclick = () => { submitRunModal.style.display = 'none'; resetSubmitRunModal(); };

    document.getElementById('submit-run-form').onsubmit = async (e) => {
        e.preventDefault();
        const timeInMs = parseTimeToMilliseconds(document.getElementById('run-time').value);
        if (isNaN(timeInMs)) return alert('Invalid time format.');
        if (state.editingRunId) {
            const updatedRunData = { playerName: document.getElementById('run-player').value, timeInMs, dateAchieved: document.getElementById('run-date').value, videoUrl: document.getElementById('run-video').value };
            await update(ref(db, `runs/${state.editingRunId}`), updatedRunData);
            alert('Run updated successfully!');
            fetchAndDisplayLeaderboard();
        } else {
            const variables = {};
            let categoryId, categoryName;
            const leaderboardType = document.getElementById('type-select').value;
            if (leaderboardType === 'fullgame') {
                const categorySelect = document.getElementById('modal-category-select');
                categoryId = categorySelect.value;
                categoryName = categorySelect.options[categorySelect.selectedIndex].text;
                document.querySelectorAll('#modal-subcategories-container select').forEach(s => { variables[s.dataset.varId] = s.value; });
            } else {
                const mainCategoryQ = query(ref(db, 'categories'), orderByChild('hack_id'), equalTo(state.hack.id));
                const catSnapshot = await get(mainCategoryQ);
                const category = snapshotToArray(catSnapshot).find(c => c.type === leaderboardType);
                categoryId = category.id; categoryName = category.name;
                const levelId = document.getElementById('modal-level-select').value;
                variables['level'] = levelId;
                if (leaderboardType === 'level_singlestar') {
                    const starSelect = document.querySelector('#modal-stars-container select');
                    if (starSelect) variables[starSelect.dataset.varId] = starSelect.value;
                }
            }
            const runRef = push(ref(db, 'runs'));
            const newRun = { hack_id: state.hack.id, category_id: categoryId, hackName: state.hack.name, categoryName: categoryName, playerName: state.user.displayName, userId: state.user.uid, timeInMs, dateAchieved: document.getElementById('run-date').value, videoUrl: document.getElementById('run-video').value, variables, status: 'pending', submittedAt: new Date().toISOString() };
            await set(runRef, newRun);
            alert('Run submitted for review!');
        }
        submitRunModal.style.display = 'none';
        resetSubmitRunModal();
    };

    // --- Sync Logic ---
    async function fetchAllSRCGames(offset = 0, allGames = []) {
        const url = `https://www.speedrun.com/api/v1/series/sm64romhacks/games?max=200&offset=${offset}`;
        try {
            const res = await fetch(url);
            if (res.status === 404) return allGames;
            if (!res.ok) throw new Error(`API fetch failed: ${res.status}`);
            const data = await res.json();
            if (data.data.length === 0) return allGames;
            allGames.push(...data.data);
            if (data.pagination.size === 200) { return fetchAllSRCGames(offset + 200, allGames); }
            return allGames;
        } catch (error) { console.error("Failed to fetch games from SRC:", error); throw error; }
    }
    async function syncWithSpeedrunCom() {
        const statusDiv = document.getElementById('sync-status'), syncBtn = document.getElementById('sync-src-btn'), force = document.getElementById('force-sync-checkbox').checked;
        syncBtn.disabled = true;
        statusDiv.innerHTML = '<div class="loader"></div>Starting sync...';
        if (force && !confirm("DELETE ALL DATA? This cannot be undone. Are you sure?")) {
            statusDiv.innerHTML = "Sync cancelled."; syncBtn.disabled = false; return;
        }

        try {
            if (force) {
                statusDiv.innerHTML = `<div class="loader"></div>Deleting all old data...`;
                await set(ref(db), null);
            }
            statusDiv.innerHTML = '<div class="loader"></div>Fetching all games from speedrun.com...';
            const allGames = await fetchAllSRCGames();
            const allUpdates = {};

            for (const [i, game] of allGames.entries()) {
                const gameName = game.names.international;
                statusDiv.innerHTML = `<div class="loader"></div>(${i + 1}/${allGames.length}) Processing: <strong>${gameName}</strong>...`;
                const hackId = slugify(gameName);

                if (!force) {
                    const existingSnap = await get(ref(db, `hacks/${hackId}`));
                    if (existingSnap.exists()) { continue; }
                }

                const dRes = await fetch(`https://www.speedrun.com/api/v1/games/${game.id}?embed=categories,levels,variables`);
                if (!dRes.ok) { continue; }
                const details = (await dRes.json()).data;
                const srcCategoryToSlugMap = new Map();
                const srcLevelToSlugMap = new Map();

                allUpdates[`/hacks/${hackId}`] = { name: gameName, year: details.released || null, imageUrl: details.assets['cover-large']?.uri || '', slug: hackId, order: i, srcId: details.id, created_at: details.created || new Date().toISOString() };

                for (const [idx, c] of (details.categories?.data || []).entries()) {
                    const catId = slugify(`${hackId}-${c.name}`);
                    srcCategoryToSlugMap.set(c.id, catId);
                    allUpdates[`/categories/${catId}`] = { name: c.name, type: c.type === 'per-level' ? (c.name.toLowerCase().includes('rta') ? 'level_rta' : 'level_singlestar') : 'fullgame', order: idx, hack_id: hackId, srcId: c.id };
                }

                for (const [l_idx, level] of (details.levels?.data || []).entries()) {
                    const levelId = slugify(`${hackId}-${level.name}`);
                    srcLevelToSlugMap.set(level.id, levelId);
                    allUpdates[`/levels/${levelId}`] = { name: level.name, order: l_idx, srcId: level.id, hack_id: hackId };
                }

                for (const v of (details.variables?.data || [])) {
                    if (v.scope.type === 'single-level') {
                        const levelId = srcLevelToSlugMap.get(v.scope.level);
                        if (levelId && v.values.values) {
                            for (const [s_idx, [id, val]] of Object.entries(v.values.values).entries()) {
                                const starId = slugify(`${levelId}-${val.label}`);
                                allUpdates[`/stars/${starId}`] = { name: val.label, order: s_idx, srcId: id, level_id: levelId };
                            }
                        }
                    } 
                    else if (v['is-subcategory']) {
                        const varId = slugify(`${hackId}-${v.name}`);
                        const varData = { name: v.name, order: i, srcId: v.id, hack_id: hackId };
                        if (v.scope.type === 'single-category' && srcCategoryToSlugMap.has(v.scope.category)) {
                            varData.category_id = srcCategoryToSlugMap.get(v.scope.category);
                        }
                        allUpdates[`/variables/${varId}`] = varData;
                        
                        if (v.values.values) {
                            for (const [o_idx, [id, val]] of Object.entries(v.values.values).entries()) {
                                const optId = slugify(`${varId}-${val.label}`);
                                allUpdates[`/options/${optId}`] = { name: val.label, order: o_idx, srcId: id, variable_id: varId };
                            }
                        }
                    }
                }
            }
            
            statusDiv.innerHTML = `<div class="loader"></div>Committing all changes...`;
            await update(ref(db), allUpdates);
            statusDiv.innerHTML = `<strong style="color: #28a745;">Sync complete! Processed ${allGames.length} games.</strong>`;
            await loadAdminData();
            await fetchAndDisplayHacks();
        } catch (error) {
            console.error("Sync Error:", error);
            statusDiv.innerHTML = `<strong style="color: #dc3545;">Sync Error:</strong> ${error.message}`;
        } finally {
            syncBtn.disabled = false;
        }
    }
</script>
</body>
</html>
