<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM64 Hacks Speedrun Mobile</title>
    <style>
        /* Basic Mobile-First CSS */
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #e0e0e0;
            --secondary-color: #888;
            --accent-color: #3d7eff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-color);
            margin: 0;
            padding: 12px;
        }
        .page { display: none; }
        .page.active { display: block; }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--surface-color);
        }
        .header h1 { font-size: 1.2em; margin: 0; }
        .header nav a { color: var(--primary-color); text-decoration: none; margin-left: 15px; }
        .controls { display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap; }
        input, select, button {
            background-color: var(--surface-color);
            color: var(--primary-color);
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            font-size: 1em;
        }
        button { cursor: pointer; background-color: var(--accent-color); border: none; }
        .game-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; }
        .game-card {
            background-color: var(--surface-color);
            border-radius: 8px;
            overflow: hidden;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .game-card:hover { transform: scale(1.05); }
        .game-card img { width: 100%; height: 100px; object-fit: cover; }
        .game-card-info { padding: 10px; }
        .game-card-info h3 { font-size: 0.9em; margin: 0 0 5px 0; }
        .game-card-info p { font-size: 0.8em; color: var(--secondary-color); margin: 0; }
        .leaderboard-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .leaderboard-table th, .leaderboard-table td { padding: 8px; text-align: left; border-bottom: 1px solid var(--surface-color); }
        .leaderboard-table th { font-size: 0.9em; color: var(--secondary-color); }
        .leaderboard-table td { font-size: 0.95em; }
        .leaderboard-table .rank { width: 30px; text-align: center; color: var(--secondary-color); }
        .leaderboard-table a { color: var(--accent-color); text-decoration: none; }
        /* Modal Styles */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: var(--surface-color); margin: 15% auto; padding: 20px;
            border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px;
        }
        .modal-content h2 { margin-top: 0; }
        .modal-content form { display: flex; flex-direction: column; gap: 15px; }
        .modal-content .form-actions { display: flex; justify-content: flex-end; gap: 10px; }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .loading { text-align: center; padding: 40px; font-size: 1.2em; color: var(--secondary-color); }
        .sub-category-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .sub-category-list button { background: var(--surface-color); }
        .sub-category-list button.active { background: var(--accent-color); font-weight: bold; }
    </style>
</head>
<body>

    <header class="header">
        <h1>SM64 Hacks Mobile</h1>
        <nav>
            <a href="#" id="home-link">Home</a>
            <a href="#" id="mod-link">Mod</a>
        </nav>
    </header>

    <!-- ==== HOME PAGE ==== -->
    <div id="home-page" class="page active">
        <h2>Games in Series</h2>
        <div class="controls">
            <input type="text" id="search-input" placeholder="Search for a hack...">
            <select id="sort-select">
                <option value="alphabetical">Sort by: Alphabetical</option>
                <option value="newest">Sort by: Newest</option>
                <option value="oldest">Sort by: Oldest</option>
            </select>
        </div>
        <div id="game-list-container" class="game-list">
            <div class="loading">Loading games...</div>
        </div>
    </div>

    <!-- ==== LEADERBOARD PAGE ==== -->
    <div id="leaderboard-page" class="page">
        <button id="back-to-home-btn">&larr; Back to Games</button>
        <h2 id="leaderboard-game-title"></h2>
        <div id="leaderboard-controls">
            <select id="category-select"></select>
            <div id="sub-category-container"></div>
        </div>
        <button id="submit-run-btn" style="margin-top: 15px;">Submit Run</button>
        <div id="leaderboard-container">
            <div class="loading">Loading leaderboard...</div>
        </div>
    </div>

    <!-- ==== MOD PAGE ==== -->
    <div id="mod-page" class="page">
        <div id="mod-login-view">
            <h2>Moderator Login</h2>
            <form id="login-form">
                <input type="email" id="login-email" placeholder="Email" required>
                <input type="password" id="login-password" placeholder="Password" required>
                <button type="submit">Login</button>
            </form>
            <p id="login-error" style="color: red;"></p>
        </div>
        <div id="mod-panel-view" style="display: none;">
            <h2>Moderation Panel</h2>
            <p>Logged in as: <span id="mod-email"></span></p>
            <button id="logout-btn">Logout</button>
            <h3>Pending Runs</h3>
            <div id="pending-runs-container">
                <div class="loading">Loading pending runs...</div>
            </div>
        </div>
    </div>

    <!-- ==== SUBMIT RUN MODAL ==== -->
    <div id="submit-run-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-modal-btn">&times;</span>
            <h2>Submit Run</h2>
            <p>Submitting for: <strong id="modal-run-info"></strong></p>
            <form id="submit-run-form">
                <input type="text" id="submit-player" placeholder="Player Name" required>
                <input type="text" id="submit-time" placeholder="Time (e.g., 1h 23m 45s 678ms)" required>
                <input type="url" id="submit-video" placeholder="Video URL (YouTube, Twitch)" required>
                <input type="date" id="submit-date" required>
                <div class="form-actions">
                    <button type="button" id="cancel-submit-btn">Cancel</button>
                    <button type="submit">Submit</button>
                </div>
            </form>
        </div>
    </div>

    <!-- ==== EDIT RUN MODAL (for mods) ==== -->
    <div id="edit-run-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="close-edit-modal-btn">&times;</span>
            <h2>Edit Run</h2>
            <form id="edit-run-form">
                <input type="hidden" id="edit-run-id">
                <input type="hidden" id="edit-run-path">
                <input type="text" id="edit-player" placeholder="Player Name" required>
                <input type="text" id="edit-time" placeholder="Time (e.g., 1h 23m 45s 678ms)" required>
                <input type="url" id="edit-video" placeholder="Video URL (YouTube, Twitch)" required>
                <input type="date" id="edit-date" required>
                <div class="form-actions">
                    <button type="button" id="cancel-edit-btn">Cancel</button>
                    <button type="submit">Save Changes</button>
                </div>
            </form>
        </div>
    </div>


    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getDatabase, ref, onValue, push, set, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
        import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAsVYnWAq5aFOz9dIxHpGVWK8Mk64f01GU",
            authDomain: "sm64-hack-roms-speedrun-mobile.firebaseapp.com",
            databaseURL: "https://sm64-hack-roms-speedrun-mobile-default-rtdb.firebaseio.com",
            projectId: "sm64-hack-roms-speedrun-mobile",
            storageBucket: "sm64-hack-roms-speedrun-mobile.firebasestorage.app",
            messagingSenderId: "499101981060",
            appId: "1:499101981060:web:209dfe3f20866ef4f865d1"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // --- GLOBAL STATE & CONSTANTS ---
        const SRC_API_BASE = 'https://www.speedrun.com/api/v1';
        const SM64_HACKS_SERIES_ID = '4d7e5m6r'; // ID for SM64 ROM Hacks series
        let allGames = [];
        let apiCache = {}; // Simple in-memory cache
        let currentLeaderboardListener = null;

        // --- UTILITY FUNCTIONS ---
        // Helper to fetch from API with caching
        async function fetchWithCache(url) {
            if (apiCache[url]) return apiCache[url];
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                apiCache[url] = data;
                return data;
            } catch (error) {
                console.error('Failed to fetch from API:', error);
                return null;
            }
        }

        // Format relative date
        function timeAgo(date) {
            const seconds = Math.floor((new Date() - new Date(date)) / 1000);
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " years ago";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " months ago";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " days ago";
            return "Today";
        }

        // Convert time string like "1h 23m 45.678s" to seconds for sorting
        function timeToSeconds(timeStr) {
            let totalSeconds = 0;
            if (!timeStr || typeof timeStr !== 'string') return Infinity;
            
            const time = timeStr.replace(/ /g, '');
            const hourMatch = time.match(/(\d+)h/);
            const minMatch = time.match(/(\d+)m/);
            const secMatch = time.match(/(\d+(\.\d+)?)s/);

            if (hourMatch) totalSeconds += parseInt(hourMatch[1]) * 3600;
            if (minMatch) totalSeconds += parseInt(minMatch[1]) * 60;
            if (secMatch) totalSeconds += parseFloat(secMatch[1]);
            
            return totalSeconds;
        }


        // --- PAGE ROUTING ---
        const pages = document.querySelectorAll('.page');
        function showPage(pageId) {
            pages.forEach(p => p.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            window.scrollTo(0, 0);
        }

        function handleRouting() {
            const params = new URLSearchParams(window.location.search);
            const gameId = params.get('game');
            const view = params.get('view');
            
            if (view === 'mod') {
                showPage('mod-page');
            } else if (gameId) {
                showPage('leaderboard-page');
                loadLeaderboardPage(gameId);
            } else {
                showPage('home-page');
                if (allGames.length === 0) loadHomePage();
            }
        }
        
        // Navigation links
        document.getElementById('home-link').addEventListener('click', (e) => {
            e.preventDefault();
            history.pushState(null, '', '/');
            handleRouting();
        });
        document.getElementById('mod-link').addEventListener('click', (e) => {
            e.preventDefault();
            history.pushState(null, '', '?view=mod');
            handleRouting();
        });
        document.getElementById('back-to-home-btn').addEventListener('click', () => {
             history.pushState(null, '', '/');
             handleRouting();
        });
        window.addEventListener('popstate', handleRouting);


        // --- HOME PAGE LOGIC ---
        async function loadHomePage() {
            const container = document.getElementById('game-list-container');
            container.innerHTML = '<div class="loading">Loading games...</div>';

            const data = await fetchWithCache(`${SRC_API_BASE}/series/${SM64_HACKS_SERIES_ID}/games?max=200&embed=platforms`);
            
            if (!data || !data.data) {
                container.innerHTML = 'Failed to load games.';
                return;
            }

            allGames = data.data.filter(g => g.romhack); // Ensure we only show romhacks
            renderGames();
        }

        function renderGames() {
            const container = document.getElementById('game-list-container');
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const sortMethod = document.getElementById('sort-select').value;

            let filteredGames = allGames.filter(game => game.names.international.toLowerCase().includes(searchTerm));

            filteredGames.sort((a, b) => {
                if (sortMethod === 'alphabetical') {
                    return a.names.international.localeCompare(b.names.international);
                }
                const dateA = new Date(a.released, 1, 1);
                const dateB = new Date(b.released, 1, 1);
                if (sortMethod === 'newest') {
                    return dateB - dateA;
                }
                if (sortMethod === 'oldest') {
                    return dateA - dateB;
                }
            });

            if (filteredGames.length === 0) {
                container.innerHTML = 'No games found.';
                return;
            }

            container.innerHTML = filteredGames.map(game => `
                <div class="game-card" data-game-id="${game.id}">
                    <img src="${game.assets['cover-medium'].uri}" alt="${game.names.international} cover">
                    <div class="game-card-info">
                        <h3>${game.names.international}</h3>
                        <p>${game.released} &bull; ${timeAgo(new Date(game.created))}</p>
                    </div>
                </div>
            `).join('');
        }

        document.getElementById('search-input').addEventListener('input', renderGames);
        document.getElementById('sort-select').addEventListener('change', renderGames);
        document.getElementById('game-list-container').addEventListener('click', (e) => {
            const card = e.target.closest('.game-card');
            if (card) {
                const gameId = card.dataset.gameId;
                history.pushState({ gameId }, '', `?game=${gameId}`);
                handleRouting();
            }
        });


        // --- LEADERBOARD PAGE LOGIC ---
        let currentGameData = {};
        
        async function loadLeaderboardPage(gameId) {
            document.getElementById('leaderboard-container').innerHTML = '<div class="loading">Loading game data...</div>';
            document.getElementById('leaderboard-game-title').textContent = '';
            document.getElementById('category-select').innerHTML = '';
            document.getElementById('sub-category-container').innerHTML = '';
            
            const [game, categories, levels] = await Promise.all([
                fetchWithCache(`${SRC_API_BASE}/games/${gameId}`),
                fetchWithCache(`${SRC_API_BASE}/games/${gameId}/categories`),
                fetchWithCache(`${SRC_API_BASE}/games/${gameId}/levels`)
            ]);
            
            if (!game || !categories || !levels) {
                document.getElementById('leaderboard-container').innerHTML = 'Failed to load game data.';
                return;
            }
            
            currentGameData = {
                id: game.data.id,
                name: game.data.names.international,
                categories: categories.data,
                levels: levels.data,
                variables: {}
            };
            
            document.getElementById('leaderboard-game-title').textContent = currentGameData.name;
            
            populateCategorySelector();
            
            const params = new URLSearchParams(window.location.search);
            const categoryId = params.get('category');
            const levelId = params.get('level');

            if (categoryId) {
                document.getElementById('category-select').value = `category_${categoryId}`;
            } else if (levelId) {
                 document.getElementById('category-select').value = `level_${levelId}`;
            }
            
            handleCategoryChange();
        }

        function populateCategorySelector() {
            const selector = document.getElementById('category-select');
            selector.innerHTML = '';
            
            const fullGameGroup = document.createElement('optgroup');
            fullGameGroup.label = 'Full Game';
            currentGameData.categories.filter(c => c.type === 'per-game').forEach(cat => {
                const option = document.createElement('option');
                option.value = `category_${cat.id}`;
                option.textContent = cat.name;
                fullGameGroup.appendChild(option);
            });
            selector.appendChild(fullGameGroup);

            if (currentGameData.levels.length > 0) {
                const levelGroup = document.createElement('optgroup');
                levelGroup.label = 'Levels';
                currentGameData.levels.forEach(level => {
                    const option = document.createElement('option');
                    option.value = `level_${level.id}`;
                    option.textContent = level.name;
                    levelGroup.appendChild(option);
                });
                selector.appendChild(levelGroup);
            }
        }
        
        async function handleCategoryChange() {
            const selector = document.getElementById('category-select');
            const [type, id] = selector.value.split('_');
            
            document.getElementById('sub-category-container').innerHTML = '';

            if (type === 'category') {
                await loadSubcategories(id, null);
            } else if (type === 'level') {
                await loadLevelSubcategories(id);
            }
        }

        async function loadSubcategories(categoryId, levelId) {
            const container = document.getElementById('sub-category-container');
            const variablesData = await fetchWithCache(`${SRC_API_BASE}/categories/${categoryId}/variables`);
            
            if (!variablesData || variablesData.data.length === 0) {
                updateLeaderboardView();
                return;
            }

            currentGameData.variables[categoryId] = variablesData.data;

            container.innerHTML = variablesData.data.map(variable => {
                const options = Object.entries(variable.values.values).map(([valueId, valueData]) =>
                    `<button class="sub-cat-btn" data-variable-id="${variable.id}" data-value-id="${valueId}">${valueData.label}</button>`
                ).join('');
                return `
                    <div>
                        <strong>${variable.name}:</strong>
                        <div class="sub-category-list" id="var-${variable.id}">${options}</div>
                    </div>
                `;
            }).join('');
            
            variablesData.data.forEach(variable => {
                const firstButton = container.querySelector(`#var-${variable.id} button`);
                if(firstButton) firstButton.classList.add('active');
            });

            updateLeaderboardView();
        }

        async function loadLevelSubcategories(levelId) {
            const container = document.getElementById('sub-category-container');
            const levelCategoriesData = await fetchWithCache(`${SRC_API_BASE}/levels/${levelId}/categories`);
            
            if (!levelCategoriesData || levelCategoriesData.data.length === 0) {
                container.innerHTML = '<p>This level has no categories.</p>';
                document.getElementById('leaderboard-container').innerHTML = '';
                return;
            }

            container.innerHTML = `
                <div>
                    <strong>Category:</strong>
                    <div class="sub-category-list">
                        ${levelCategoriesData.data.map(cat => `
                            <button class="level-cat-btn" data-category-id="${cat.id}" data-category-name="${cat.name}">${cat.name}</button>
                        `).join('')}
                    </div>
                </div>
                <div id="star-selector-container"></div>
            `;
            
            const firstButton = container.querySelector('.level-cat-btn');
            if (firstButton) {
                firstButton.classList.add('active');
                await handleLevelCategorySelection(firstButton.dataset.categoryId, firstButton.dataset.categoryName);
            }
        }

        async function handleLevelCategorySelection(categoryId, categoryName) {
            const starContainer = document.getElementById('star-selector-container');
            starContainer.innerHTML = '';
            
            if (categoryName.toLowerCase().includes('single star')) {
                starContainer.innerHTML = '<div class="loading">Loading stars...</div>';
                const variablesData = await fetchWithCache(`${SRC_API_BASE}/categories/${categoryId}/variables`);
                if (variablesData && variablesData.data.length > 0) {
                    const starVariable = variablesData.data[0];
                    currentGameData.variables[categoryId] = variablesData.data;

                    const starOptions = Object.entries(starVariable.values.values).map(([valueId, valueData]) => 
                        `<option value="${valueId}">${valueData.label}</option>`
                    ).join('');

                    starContainer.innerHTML = `
                        <div>
                            <strong>Star:</strong>
                            <select id="star-select" data-variable-id="${starVariable.id}">
                                ${starOptions}
                            </select>
                        </div>
                    `;
                    document.getElementById('star-select').addEventListener('change', updateLeaderboardView);
                } else {
                     starContainer.innerHTML = '<p>Could not load stars for this category.</p>';
                }
            }
            
            updateLeaderboardView();
        }

        function updateLeaderboardView() {
            const params = new URLSearchParams();
            params.set('game', currentGameData.id);

            const mainSelection = document.getElementById('category-select').value;
            const [type, mainId] = mainSelection.split('_');

            let dbPath = `leaderboards/${currentGameData.id}`;
            let runInfoText = `${currentGameData.name} - `;
            
            if (type === 'level') {
                params.set('level', mainId);
                dbPath += `/level_${mainId}`;
                const level = currentGameData.levels.find(l => l.id === mainId);
                runInfoText += `${level.name} - `;

                const activeLevelCatBtn = document.querySelector('.level-cat-btn.active');
                if (activeLevelCatBtn) {
                    const catId = activeLevelCatBtn.dataset.categoryId;
                    const catName = activeLevelCatBtn.dataset.categoryName;
                    params.set('levelcat', catId);
                    dbPath += `/${catId}`;
                    runInfoText += `${catName}`;
                    
                    if (catName.toLowerCase().includes('single star')) {
                        const starSelect = document.getElementById('star-select');
                        if (starSelect) {
                            const starVarId = starSelect.dataset.variableId;
                            const starValueId = starSelect.value;
                            params.set(`var-${starVarId}`, starValueId);
                            dbPath += `/${starVarId}_${starValueId}`;
                            runInfoText += ` - ${starSelect.options[starSelect.selectedIndex].text}`;
                        }
                    }
                }
            } else {
                params.set('category', mainId);
                dbPath += `/category_${mainId}`;
                const category = currentGameData.categories.find(c => c.id === mainId);
                runInfoText += category.name;

                const activeSubCatBtns = document.querySelectorAll('.sub-cat-btn.active');
                activeSubCatBtns.forEach(btn => {
                    const varId = btn.dataset.variableId;
                    const valId = btn.dataset.valueId;
                    params.set(`var-${varId}`, valId);
                    dbPath += `/${varId}_${valId}`;
                     const variable = currentGameData.variables[mainId]?.find(v => v.id === varId);
                     if(variable) runInfoText += ` (${variable.values.values[valId].label})`;
                });
            }

            history.replaceState(null, '', `?${params.toString()}`);
            
            document.getElementById('modal-run-info').textContent = runInfoText;
            document.getElementById('submit-run-btn').dataset.dbPath = dbPath;
            document.getElementById('submit-run-btn').dataset.runInfo = runInfoText;
            
            loadRunsFromFirebase(dbPath);
        }
        
        function loadRunsFromFirebase(dbPath) {
            const container = document.getElementById('leaderboard-container');
            container.innerHTML = '<div class="loading">Loading leaderboard...</div>';

            if (currentLeaderboardListener) {
                currentLeaderboardListener();
            }

            const leaderboardRef = ref(db, dbPath);
            currentLeaderboardListener = onValue(leaderboardRef, (snapshot) => {
                const data = snapshot.val();
                if (!data) {
                    container.innerHTML = '<p>No runs submitted for this category yet.</p>';
                    return;
                }

                const runs = Object.entries(data).map(([key, value]) => ({ id: key, ...value }));
                runs.sort((a, b) => timeToSeconds(a.time) - timeToSeconds(b.time));

                container.innerHTML = `
                    <table class="leaderboard-table">
                        <thead><tr><th class="rank">#</th><th>Player</th><th>Time</th><th>Date</th></tr></thead>
                        <tbody>
                            ${runs.map((run, index) => `
                                <tr>
                                    <td class="rank">${index + 1}</td>
                                    <td>${run.player}</td>
                                    <td><a href="${run.video}" target="_blank" rel="noopener noreferrer">${run.time}</a></td>
                                    <td>${timeAgo(run.date)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }, (error) => {
                console.error(error);
                container.innerHTML = '<p>Error loading leaderboard.</p>';
            });
        }
        
        document.getElementById('category-select').addEventListener('change', handleCategoryChange);
        document.getElementById('sub-category-container').addEventListener('click', (e) => {
            if (e.target.matches('.sub-cat-btn')) {
                const siblings = e.target.parentElement.querySelectorAll('.sub-cat-btn');
                siblings.forEach(s => s.classList.remove('active'));
                e.target.classList.add('active');
                updateLeaderboardView();
            }
            if (e.target.matches('.level-cat-btn')) {
                const siblings = e.target.parentElement.querySelectorAll('.level-cat-btn');
                siblings.forEach(s => s.classList.remove('active'));
                e.target.classList.add('active');
                handleLevelCategorySelection(e.target.dataset.categoryId, e.target.dataset.categoryName);
            }
        });
        

        // --- SUBMIT RUN MODAL LOGIC ---
        const submitModal = document.getElementById('submit-run-modal');
        document.getElementById('submit-run-btn').addEventListener('click', () => {
            document.getElementById('submit-run-form').reset();
            submitModal.style.display = 'block';
        });
        document.getElementById('close-modal-btn').addEventListener('click', () => submitModal.style.display = 'none');
        document.getElementById('cancel-submit-btn').addEventListener('click', () => submitModal.style.display = 'none');

        document.getElementById('submit-run-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const dbPath = document.getElementById('submit-run-btn').dataset.dbPath;
            const runInfo = document.getElementById('submit-run-btn').dataset.runInfo;
            
            if (!dbPath) {
                alert('Error: Could not determine leaderboard category.');
                return;
            }

            const runData = {
                player: document.getElementById('submit-player').value,
                time: document.getElementById('submit-time').value,
                video: document.getElementById('submit-video').value,
                date: document.getElementById('submit-date').value,
                submittedAt: new Date().toISOString(),
                leaderboardPath: dbPath,
                runInfo: runInfo
            };

            try {
                await push(ref(db, 'pending_runs'), runData);
                submitModal.style.display = 'none';
                alert('Run submitted successfully! It will appear on the leaderboard after moderator approval.');
            } catch (error) {
                console.error('Error submitting run:', error);
                alert('There was an error submitting your run.');
            }
        });

        // --- MODERATION LOGIC ---
        const modLoginView = document.getElementById('mod-login-view');
        const modPanelView = document.getElementById('mod-panel-view');

        onAuthStateChanged(auth, user => {
            if (user) {
                modLoginView.style.display = 'none';
                modPanelView.style.display = 'block';
                document.getElementById('mod-email').textContent = user.email;
                loadPendingRuns();
            } else {
                modLoginView.style.display = 'block';
                modPanelView.style.display = 'none';
            }
        });

        document.getElementById('login-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            signInWithEmailAndPassword(auth, email, password)
                .catch(error => {
                    document.getElementById('login-error').textContent = error.message;
                });
        });

        document.getElementById('logout-btn').addEventListener('click', () => {
            signOut(auth);
        });

        function loadPendingRuns() {
            const container = document.getElementById('pending-runs-container');
            const pendingRef = ref(db, 'pending_runs');
            onValue(pendingRef, (snapshot) => {
                const data = snapshot.val();
                if (!data) {
                    container.innerHTML = '<p>No pending runs.</p>';
                    return;
                }
                container.innerHTML = Object.entries(data).map(([key, run]) => `
                    <div style="background: #333; padding: 10px; margin-bottom: 10px; border-radius: 5px;">
                        <p><strong>${run.runInfo}</strong></p>
                        <p>Player: ${run.player} | Time: ${run.time}</p>
                        <p>Video: <a href="${run.video}" target="_blank">Link</a> | Date: ${run.date}</p>
                        <button class="approve-btn" data-run-id="${key}">Approve</button>
                        <button class="reject-btn" data-run-id="${key}" style="background: #c00;">Reject</button>
                        <button class="edit-btn" data-run-id="${key}" style="background: #f5a623;">Edit</button>
                    </div>
                `).join('');
            });
        }
        
        document.getElementById('pending-runs-container').addEventListener('click', async e => {
            const runId = e.target.dataset.runId;
            if (!runId) return;

            const pendingRunRef = ref(db, `pending_runs/${runId}`);
            
            if (e.target.matches('.approve-btn')) {
                onValue(pendingRunRef, (snapshot) => {
                    const runData = snapshot.val();
                    if (!runData) return;
                    
                    const newRunRef = ref(db, runData.leaderboardPath);
                    const runToApprove = {
                        player: runData.player,
                        time: runData.time,
                        video: runData.video,
                        date: runData.date
                    };
                    push(newRunRef, runToApprove).then(() => {
                        remove(pendingRunRef);
                    });
                }, { onlyOnce: true });
            }
            
            if (e.target.matches('.reject-btn')) {
                if (confirm('Are you sure you want to reject this run?')) {
                    remove(pendingRunRef);
                }
            }

            if (e.target.matches('.edit-btn')) {
                alert("Edit functionality would open a pre-filled modal similar to the submit one.");
            }
        });
        
        // --- INITIALIZATION ---
        handleRouting();

    </script>
</body>
</html>
